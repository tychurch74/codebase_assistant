{
  "codebase_assistant": {
    "src": {
      "code_gen": {
        "docstring": null,
        "functions_and_classes": {}
      },
      "gpt_funcs": {
        "docstring": null,
        "functions_and_classes": {
          "code_to_nl": {
            "nl_description": "This is a Python function called `code_to_nl` that takes in three arguments: `input_content`, `model_temperature`, and `model`. \n\nInside the function, there is a variable called `system_message` which is a dictionary containing information about the AI system. It has two key-value pairs: `role` with the value `'system'` and `content` with a long string explaining the purpose of the AI.\n\nThere is also a variable called `user_message` which is a dictionary containing information about the user's input. It has two key-value pairs: `role` with the value `'user'` and `content` with the value of the `input_content` argument passed to the function.\n\nThe function then makes a call to the OpenAI API using the `openai.ChatCompletion.create` method. It passes the `model`, `messages`, and `temperature` arguments to the method. The `model` argument specifies the model to use for the chat completion, the `messages` argument is a list containing the `system_message` and `user_message` dictionaries, and the `temperature` argument controls the randomness of the response generated by the model.\n\nFinally, the function returns the generated response by accessing the appropriate keys in the response dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='code_to_nl', args=arguments(posonlyargs=[], args=[arg(arg='input_content'), arg(arg='model_temperature'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.1), Constant(value='gpt-3.5-turbo')]), body=[Assign(targets=[Name(id='system_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Constant(value=\"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\")])), Assign(targets=[Name(id='user_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='input_content', ctx=Load())])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='messages', value=List(elts=[Name(id='system_message', ctx=Load()), Name(id='user_message', ctx=Load())], ctx=Load())), keyword(arg='temperature', value=Name(id='model_temperature', ctx=Load()))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef code_to_nl(input_content, model_temperature=0.1, model='gpt-3.5-turbo'):\n    system_message = {'role': 'system', 'content': \"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\"}\n    user_message = {'role': 'user', 'content': input_content}\n    response = openai.ChatCompletion.create(model=model, messages=[system_message, user_message], temperature=model_temperature)\n    return response['choices'][0]['message']['content']\n"
          }
        }
      },
      "parser": {
        "docstring": null,
        "functions_and_classes": {
          "extract_info": {
            "nl_description": "This code defines a function called `extract_info` that takes a parameter called `node`. \n\nInside the function, it checks if the `node` is an instance of either `ast.FunctionDef` or `ast.ClassDef`. If it is, it retrieves the docstring of the `node` using the `ast.get_docstring` function and assigns it to the variable `docstring`. It also dumps the abstract syntax tree (AST) representation of the `node` using the `ast.dump` function and assigns it to the variable `ast_output`. Additionally, it converts the `node` back to source code using the `astunparse.unparse` function and assigns it to the variable `source_code`.\n\nNext, it calls a function called `code_to_nl` with the `source_code` as an argument to convert the source code to natural language description and assigns the result to the variable `nl_description`.\n\nFinally, it returns a dictionary with the keys `'nl_description'`, `'docstring'`, `'ast_output'`, and `'source_code'`, and their corresponding values `nl_description`, `docstring`, `ast_output`, and `source_code` respectively. If the `node` is not an instance of `ast.FunctionDef` or `ast.ClassDef`, it returns `None`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='extract_info', args=arguments(posonlyargs=[], args=[arg(arg='node')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='ast', ctx=Load()), attr='FunctionDef', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='ClassDef', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='astunparse', ctx=Load()), attr='unparse', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nl_desription', ctx=Store())], value=Call(func=Name(id='code_to_nl', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Return(value=Dict(keys=[Constant(value='nl_description'), Constant(value='docstring'), Constant(value='ast_output'), Constant(value='source_code')], values=[Name(id='nl_desription', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load())]))], orelse=[Return(value=Constant(value=None))])], decorator_list=[])",
            "source_code": "\n\ndef extract_info(node):\n    if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n        docstring = ast.get_docstring(node)\n        ast_output = ast.dump(node)\n        source_code = astunparse.unparse(node)\n        nl_desription = code_to_nl(source_code)\n        return {'nl_description': nl_desription, 'docstring': docstring, 'ast_output': ast_output, 'source_code': source_code}\n    else:\n        return None\n"
          },
          "parse_file": {
            "nl_description": "This code defines a function called `parse_file` that takes a `file_path` as input. \n\nInside the function, it opens the file specified by `file_path` in read mode using the `open` function and assigns the file object to the variable `file`. \n\nIt then reads the contents of the file using the `read` method of the file object and assigns the result to the variable `source_code`. \n\nThe `ast.parse` function is used to parse the `source_code` and create an abstract syntax tree (AST) representation of the code. \n\nThe `ast.get_docstring` function is used to extract the docstring of the module from the AST and assigns it to the variable `module_docstring`. \n\nA dictionary called `functions_and_classes` is created to store information about the functions and classes found in the module. \n\nThe code then iterates over the `body` attribute of the module's AST and calls a function called `extract_info` on each node. The result of `extract_info` is assigned to the variable `info`. \n\nIf `info` is not `None`, meaning that `extract_info` returned some information, the code adds an entry to the `functions_and_classes` dictionary with the node's name as the key and `info` as the value. \n\nFinally, the function returns a dictionary with two keys: `'docstring'` and `'functions_and_classes'`. The value associated with the `'docstring'` key is the module's docstring, and the value associated with the `'functions_and_classes'` key is the `functions_and_classes` dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Assign(targets=[Name(id='functions_and_classes', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='node', ctx=Store()), iter=Attribute(value=Name(id='module', ctx=Load()), attr='body', ctx=Load()), body=[Assign(targets=[Name(id='info', ctx=Store())], value=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='info', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='functions_and_classes', ctx=Load()), slice=Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='info', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Dict(keys=[Constant(value='docstring'), Constant(value='functions_and_classes')], values=[Name(id='module_docstring', ctx=Load()), Name(id='functions_and_classes', ctx=Load())]))], decorator_list=[])",
            "source_code": "\n\ndef parse_file(file_path):\n    with open(file_path, 'r') as file:\n        source_code = file.read()\n    module = ast.parse(source_code)\n    module_docstring = ast.get_docstring(module)\n    functions_and_classes = {}\n    for node in module.body:\n        info = extract_info(node)\n        if (info is not None):\n            functions_and_classes[node.name] = info\n    return {'docstring': module_docstring, 'functions_and_classes': functions_and_classes}\n"
          },
          "parse_directory": {
            "nl_description": "This code defines a function called `parse_directory` that takes a `directory_path` as input. \n\nInside the function, an empty dictionary called `modules` is created. \n\nThe code then iterates over the files in the specified directory using the `os.listdir` function. \n\nFor each file, it checks if the file ends with the extension '.py' using the `endswith` method. \n\nIf the file has the '.py' extension, it creates the full file path by joining the directory path and the file name using the `os.path.join` function. \n\nIt then extracts the module name by removing the file extension using the `os.path.splitext` function. \n\nThe code then calls a function called `parse_file` with the file path as an argument and assigns the result to the `modules` dictionary with the module name as the key. \n\nFinally, the function returns the `modules` dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_directory', args=arguments(posonlyargs=[], args=[arg(arg='directory_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='modules', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='filename', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='directory_path', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.py')], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='directory_path', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Subscript(value=Name(id='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='parse_file', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='modules', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_directory(directory_path):\n    modules = {}\n    for filename in os.listdir(directory_path):\n        if filename.endswith('.py'):\n            file_path = os.path.join(directory_path, filename)\n            module_name = os.path.splitext(filename)[0]\n            modules[module_name] = parse_file(file_path)\n    return modules\n"
          }
        }
      },
      "__init__": {
        "docstring": null,
        "functions_and_classes": {}
      }
    }
  }
}