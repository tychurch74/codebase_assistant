{
  "codebase_assistant": {
    "ex_codebase": {
      "ex_code_parser": {
        "full_path": "ex_codebase\\ex_code_parser.py",
        "docstring": null,
        "functions_and_classes": {
          "extract_info": {
            "name": "extract_info",
            "nl_description": "This code defines a function called `extract_info` that takes in an AST node as an argument. If the node is an instance of `ast.FunctionDef` or `ast.ClassDef`, the function extracts the docstring, AST output, source code, and a natural language description of the source code. The function then returns a dictionary containing these values. If the node is not an instance of `ast.FunctionDef` or `ast.ClassDef`, the function returns `None`.",
            "docstring": "Extract docstrings and AST dumps for functions and classes.\n\nArgs:\n    node (ast.AST): An AST node.\n\nReturns:\n    dict: A dictionary containing natural language description, docstring, AST output, and source code\n          if the node is an instance of ast.FunctionDef or ast.ClassDef; None otherwise.",
            "ast_output": "FunctionDef(name='extract_info', args=arguments(posonlyargs=[], args=[arg(arg='node')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Extract docstrings and AST dumps for functions and classes.\\n\\n    Args:\\n        node (ast.AST): An AST node.\\n\\n    Returns:\\n        dict: A dictionary containing natural language description, docstring, AST output, and source code\\n              if the node is an instance of ast.FunctionDef or ast.ClassDef; None otherwise.\\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='ast', ctx=Load()), attr='FunctionDef', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='ClassDef', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='astunparse', ctx=Load()), attr='unparse', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nl_description', ctx=Store())], value=Call(func=Name(id='code_to_nl', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Return(value=Dict(keys=[Constant(value='nl_description'), Constant(value='docstring'), Constant(value='ast_output'), Constant(value='source_code')], values=[Name(id='nl_description', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load())]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef extract_info(node):\n    '\\n    Extract docstrings and AST dumps for functions and classes.\\n\\n    Args:\\n        node (ast.AST): An AST node.\\n\\n    Returns:\\n        dict: A dictionary containing natural language description, docstring, AST output, and source code\\n              if the node is an instance of ast.FunctionDef or ast.ClassDef; None otherwise.\\n    '\n    if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n        docstring = ast.get_docstring(node)\n        ast_output = ast.dump(node)\n        source_code = astunparse.unparse(node)\n        nl_description = code_to_nl(source_code)\n        return {'nl_description': nl_description, 'docstring': docstring, 'ast_output': ast_output, 'source_code': source_code}\n"
          },
          "parse_file": {
            "name": "parse_file",
            "nl_description": "A function called parse_file is defined. It takes a file_path as an argument and returns a dictionary containing the module docstring and a dictionary of the functions and classes in the Python file specified by the file_path. The function reads the source code from the file, parses it using the ast module, extracts the module docstring using ast.get_docstring, and extracts information about the functions and classes using the extract_info function. The resulting dictionary is then returned.",
            "docstring": "Parse a Python file.\n\nArgs:\n    file_path (str): The path to the Python file.\n\nReturns:\n    dict: A dictionary containing the module docstring and a dictionary of the functions and classes.",
            "ast_output": "FunctionDef(name='parse_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse a Python file.\\n\\n    Args:\\n        file_path (str): The path to the Python file.\\n\\n    Returns:\\n        dict: A dictionary containing the module docstring and a dictionary of the functions and classes.\\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Assign(targets=[Name(id='functions_and_classes', ctx=Store())], value=DictComp(key=Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load()), value=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='node', ctx=Store()), iter=Attribute(value=Name(id='module', ctx=Load()), attr='body', ctx=Load()), ifs=[Compare(left=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)])), Return(value=Dict(keys=[Constant(value='docstring'), Constant(value='functions_and_classes')], values=[Name(id='module_docstring', ctx=Load()), Name(id='functions_and_classes', ctx=Load())]))], decorator_list=[])",
            "source_code": "\n\ndef parse_file(file_path):\n    '\\n    Parse a Python file.\\n\\n    Args:\\n        file_path (str): The path to the Python file.\\n\\n    Returns:\\n        dict: A dictionary containing the module docstring and a dictionary of the functions and classes.\\n    '\n    with open(file_path, 'r') as file:\n        source_code = file.read()\n    module = ast.parse(source_code)\n    module_docstring = ast.get_docstring(module)\n    functions_and_classes = {node.name: extract_info(node) for node in module.body if (extract_info(node) is not None)}\n    return {'docstring': module_docstring, 'functions_and_classes': functions_and_classes}\n"
          },
          "parse_directory": {
            "name": "parse_directory",
            "nl_description": "A function called parse_directory is defined. It takes a directory_path as an argument and returns a dictionary of modules parsed from the directory. The function uses a dictionary comprehension to iterate over the files in the directory and parse each file using the parse_file function. The keys of the dictionary are the filenames without the file extension. The function only includes files with a .py extension.",
            "docstring": "Parse a directory.\n\nArgs:\n    directory_path (str): The path to the directory.\n\nReturns:\n    dict: A dictionary of the modules parsed from the directory.",
            "ast_output": "FunctionDef(name='parse_directory', args=arguments(posonlyargs=[], args=[arg(arg='directory_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse a directory.\\n\\n    Args:\\n        directory_path (str): The path to the directory.\\n\\n    Returns:\\n        dict: A dictionary of the modules parsed from the directory.\\n    ')), Assign(targets=[Name(id='modules', ctx=Store())], value=DictComp(key=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), value=Call(func=Name(id='parse_file', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='directory_path', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='filename', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='directory_path', ctx=Load())], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.py')], keywords=[])], is_async=0)])), Return(value=Name(id='modules', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_directory(directory_path):\n    '\\n    Parse a directory.\\n\\n    Args:\\n        directory_path (str): The path to the directory.\\n\\n    Returns:\\n        dict: A dictionary of the modules parsed from the directory.\\n    '\n    modules = {os.path.splitext(filename)[0]: parse_file(os.path.join(directory_path, filename)) for filename in os.listdir(directory_path) if filename.endswith('.py')}\n    return modules\n"
          },
          "parse_codebase": {
            "name": "parse_codebase",
            "nl_description": "A function called parse_codebase is defined. This function checks if a workspace exists, prompts the user for the project folder name and directory location, creates a JSON file with this information, and creates a SQLite database from the JSON file. It returns the path to the database file.",
            "docstring": "Parse a codebase.\n\nThis function checks if a workspace exists, prompts the user for the project folder name and\ndirectory location, creates a JSON file with this information, and creates a SQLite database from\nthe JSON file.\n\nReturns:\n    str: The path to the database file.",
            "ast_output": "FunctionDef(name='parse_codebase', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse a codebase.\\n\\n    This function checks if a workspace exists, prompts the user for the project folder name and\\n    directory location, creates a JSON file with this information, and creates a SQLite database from\\n    the JSON file.\\n\\n    Returns:\\n        str: The path to the database file.\\n    ')), Assign(targets=[Name(id='workspace', ctx=Store())], value=Constant(value='gpt_workspace')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='workspace', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='mkdir', ctx=Load()), args=[Name(id='workspace', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='project_folder_name', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Project folder name: ')], keywords=[])), Assign(targets=[Name(id='directory_location', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Directory location: ')], keywords=[])), Assign(targets=[Name(id='json_filename', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='workspace', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.json')])), Assign(targets=[Name(id='db_filename', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='workspace', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.db')])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='json_filename', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='modules', ctx=Store())], value=Call(func=Name(id='parse_directory', ctx=Load()), args=[Name(id='directory_location', ctx=Load())], keywords=[])), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Name(id='project_folder_name', ctx=Load())], values=[Dict(keys=[Name(id='directory_location', ctx=Load())], values=[Name(id='modules', ctx=Load())])])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_filename', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=2))]))])], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='db_filename', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Name(id='create_db', ctx=Load()), args=[Name(id='json_filename', ctx=Load()), Name(id='db_filename', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='db_filename', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_codebase():\n    '\\n    Parse a codebase.\\n\\n    This function checks if a workspace exists, prompts the user for the project folder name and\\n    directory location, creates a JSON file with this information, and creates a SQLite database from\\n    the JSON file.\\n\\n    Returns:\\n        str: The path to the database file.\\n    '\n    workspace = 'gpt_workspace'\n    if (not os.path.exists(workspace)):\n        os.mkdir(workspace)\n    project_folder_name = input('Project folder name: ')\n    directory_location = input('Directory location: ')\n    json_filename = f'{workspace}/{project_folder_name}-{directory_location}_info.json'\n    db_filename = f'{workspace}/{project_folder_name}-{directory_location}_info.db'\n    if (not os.path.exists(json_filename)):\n        modules = parse_directory(directory_location)\n        data = {project_folder_name: {directory_location: modules}}\n        with open(json_filename, 'w') as file:\n            json.dump(data, file, indent=2)\n    if (not os.path.exists(db_filename)):\n        create_db(json_filename, db_filename)\n    return db_filename\n"
          }
        }
      },
      "ex_gpt_funcs": {
        "full_path": "ex_codebase\\ex_gpt_funcs.py",
        "docstring": null,
        "functions_and_classes": {
          "code_to_nl": {
            "name": "code_to_nl",
            "nl_description": "This code defines a function called `code_to_nl` that takes in an `input_content` parameter, as well as optional parameters `model_temperature` and `model`. It then creates a `system_message` and a `user_message` based on the input content. The code then uses the OpenAI API to generate a response by passing the `system_message`, `user_message`, `model_temperature`, and `model` to the `openai.ChatCompletion.create` method. Finally, it returns the content of the generated response.\n\nOne potential improvement to the code could be to add error handling in case the API call fails or returns an unexpected response.",
            "docstring": null,
            "ast_output": "FunctionDef(name='code_to_nl', args=arguments(posonlyargs=[], args=[arg(arg='input_content'), arg(arg='model_temperature'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.1), Constant(value='gpt-3.5-turbo')]), body=[Assign(targets=[Name(id='system_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Constant(value=\"You are an AI trained by openai to read code and translate what the code does into natural language as well make suggestions on potential improvements to the code. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code. Keep your responses as short and concise as possible.\")])), Assign(targets=[Name(id='user_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='input_content', ctx=Load())])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='messages', value=List(elts=[Name(id='system_message', ctx=Load()), Name(id='user_message', ctx=Load())], ctx=Load())), keyword(arg='temperature', value=Name(id='model_temperature', ctx=Load()))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef code_to_nl(input_content, model_temperature=0.1, model='gpt-3.5-turbo'):\n    system_message = {'role': 'system', 'content': \"You are an AI trained by openai to read code and translate what the code does into natural language as well make suggestions on potential improvements to the code. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code. Keep your responses as short and concise as possible.\"}\n    user_message = {'role': 'user', 'content': input_content}\n    response = openai.ChatCompletion.create(model=model, messages=[system_message, user_message], temperature=model_temperature)\n    return response['choices'][0]['message']['content']\n"
          },
          "code_helper": {
            "name": "code_helper",
            "nl_description": "This code defines a function called `code_helper` that takes in several parameters: `input_content`, `context`, `model_temperature`, and `model`. It then creates a `system_message` dictionary and a `user_message` dictionary. The function then makes a call to the OpenAI ChatCompletion API using the specified model and messages. Finally, it returns the content of the response from the API call.\n\nPotential improvements:\n- Add error handling for API call failures.\n- Validate the input parameters to ensure they are of the correct type and format.\n- Consider adding more detailed comments to explain the purpose of each section of the code.",
            "docstring": null,
            "ast_output": "FunctionDef(name='code_helper', args=arguments(posonlyargs=[], args=[arg(arg='input_content'), arg(arg='context'), arg(arg='model_temperature'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.2), Constant(value='gpt-4-0314')]), body=[Assign(targets=[Name(id='system_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), JoinedStr(values=[Constant(value=\"You are an AI trained by openai to assist users with their codebases. To help inform your responses you will be given relevant context retrieved from the user's codebase. This context will include the name of a specific function or class, a natural language explanation of said function or class and the actual source code of said function or class. If you are unable to answer the user's query with the following context provided you may ask the user for more information. Context: \"), FormattedValue(value=Name(id='context', ctx=Load()), conversion=-1)])])), Assign(targets=[Name(id='user_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='input_content', ctx=Load())])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='messages', value=List(elts=[Name(id='system_message', ctx=Load()), Name(id='user_message', ctx=Load())], ctx=Load())), keyword(arg='temperature', value=Name(id='model_temperature', ctx=Load()))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef code_helper(input_content, context, model_temperature=0.2, model='gpt-4-0314'):\n    system_message = {'role': 'system', 'content': f\"You are an AI trained by openai to assist users with their codebases. To help inform your responses you will be given relevant context retrieved from the user's codebase. This context will include the name of a specific function or class, a natural language explanation of said function or class and the actual source code of said function or class. If you are unable to answer the user's query with the following context provided you may ask the user for more information. Context: {context}\"}\n    user_message = {'role': 'user', 'content': input_content}\n    response = openai.ChatCompletion.create(model=model, messages=[system_message, user_message], temperature=model_temperature)\n    return response['choices'][0]['message']['content']\n"
          }
        }
      }
    }
  }
}