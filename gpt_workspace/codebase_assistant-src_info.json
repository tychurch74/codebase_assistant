{
  "codebase_assistant": {
    "src": {
      "__init__": {
        "docstring": null,
        "functions_and_classes": {}
      },
      "code_gen": {
        "docstring": null,
        "functions_and_classes": {}
      },
      "db_gen": {
        "docstring": null,
        "functions_and_classes": {
          "create_connection": {
            "nl_description": "A Python function called create_connection is defined. This function takes a parameter called db_file, which is a string representing the path to a SQLite database file. \n\nInside the function, there is a try-except block. The code inside the try block attempts to create a connection to the SQLite database using the sqlite3.connect() function, passing in the db_file parameter. If the connection is successfully created, it is returned from the function.\n\nIf an error occurs during the creation of the connection, the except block is executed. The error message is printed to the console using the print() function, and None is returned from the function.\n\nIn summary, this function creates a connection to a SQLite database file and returns the connection object if successful, or None if an error occurs.",
            "docstring": "Create a database connection to a SQLite database.\n\nArgs:\n    db_file (str): Path to the database file.\n\nReturns:\n    Connection object or None",
            "ast_output": "FunctionDef(name='create_connection', args=arguments(posonlyargs=[], args=[arg(arg='db_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Create a database connection to a SQLite database.\\n\\n    Args:\\n        db_file (str): Path to the database file.\\n\\n    Returns:\\n        Connection object or None\\n    ')), Try(body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Name(id='db_file', ctx=Load())], keywords=[])), Return(value=Name(id='conn', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[])), Return(value=Constant(value=None))])], orelse=[], finalbody=[])], decorator_list=[])",
            "source_code": "\n\ndef create_connection(db_file):\n    '\\n    Create a database connection to a SQLite database.\\n\\n    Args:\\n        db_file (str): Path to the database file.\\n\\n    Returns:\\n        Connection object or None\\n    '\n    try:\n        conn = sqlite3.connect(db_file)\n        return conn\n    except Error as e:\n        print(e)\n        return None\n"
          },
          "create_tables": {
            "nl_description": "This code defines a function called `create_tables` that takes a parameter `conn`, which is a connection object to an SQLite database. The function attempts to create several tables in the database using SQL queries.\n\nThe function starts by creating a cursor object using the `cursor` method of the connection object. It then defines a list called `tables` that contains multiple SQL queries, each representing the creation of a table in the database.\n\nThe function then enters a `try` block where it iterates over each query in the `tables` list. For each query, it executes the query using the `execute` method of the cursor object.\n\nIf an error occurs during the execution of any query, the function catches the error and prints it to the console using the `print` function.\n\nNote: The code contains newline characters represented by `\\n`, but they are not part of the actual code and can be ignored.",
            "docstring": "Create tables in the SQLite database.\n\nArgs:\n    conn (sqlite3.Connection): Connection object to the SQLite database.",
            "ast_output": "FunctionDef(name='create_tables', args=arguments(posonlyargs=[], args=[arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Create tables in the SQLite database.\\n\\n    Args:\\n        conn (sqlite3.Connection): Connection object to the SQLite database.\\n    ')), Try(body=[Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='tables', ctx=Store())], value=List(elts=[Constant(value='\\n            CREATE TABLE projects (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL\\n            );\\n            '), Constant(value='\\n            CREATE TABLE folders (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                project_id INTEGER,\\n                FOREIGN KEY(project_id) REFERENCES projects(id)\\n            );\\n            '), Constant(value='\\n            CREATE TABLE files (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                docstring TEXT,\\n                folder_id INTEGER,\\n                FOREIGN KEY(folder_id) REFERENCES folders(id)\\n            );\\n            '), Constant(value='\\n            CREATE TABLE functions_classes (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                nl_description TEXT,\\n                docstring TEXT,\\n                ast_output TEXT,\\n                source_code TEXT,\\n                file_id INTEGER,\\n                FOREIGN KEY(file_id) REFERENCES files(id)\\n            );\\n            ')], ctx=Load())), For(target=Name(id='table', ctx=Store()), iter=Name(id='tables', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='table', ctx=Load())], keywords=[]))], orelse=[])], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])",
            "source_code": "\n\ndef create_tables(conn):\n    '\\n    Create tables in the SQLite database.\\n\\n    Args:\\n        conn (sqlite3.Connection): Connection object to the SQLite database.\\n    '\n    try:\n        cursor = conn.cursor()\n        tables = ['\\n            CREATE TABLE projects (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL\\n            );\\n            ', '\\n            CREATE TABLE folders (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                project_id INTEGER,\\n                FOREIGN KEY(project_id) REFERENCES projects(id)\\n            );\\n            ', '\\n            CREATE TABLE files (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                docstring TEXT,\\n                folder_id INTEGER,\\n                FOREIGN KEY(folder_id) REFERENCES folders(id)\\n            );\\n            ', '\\n            CREATE TABLE functions_classes (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                nl_description TEXT,\\n                docstring TEXT,\\n                ast_output TEXT,\\n                source_code TEXT,\\n                file_id INTEGER,\\n                FOREIGN KEY(file_id) REFERENCES files(id)\\n            );\\n            ']\n        for table in tables:\n            cursor.execute(table)\n    except Error as e:\n        print(e)\n"
          },
          "parse_json_insert_data": {
            "nl_description": "This code defines a function called `parse_json_insert_data` that takes two arguments: `conn` and `json_file_path`. The function is responsible for parsing JSON data and inserting it into an SQLite database.\n\nThe function begins by opening the JSON file specified by `json_file_path` using the `open` function and assigns the file object to the variable `f`. The JSON data is then loaded from the file using the `json.load` function and assigned to the variable `data`.\n\nNext, the function creates a cursor object from the `conn` connection using the `cursor` method. The cursor is used to execute SQL statements on the database.\n\nThe function then iterates over the items in the `data` dictionary using a `for` loop. Each item represents a project name and its associated folders. For each project, an SQL statement is executed to insert the project name into the \"projects\" table using the `execute` method of the cursor. The `lastrowid` attribute of the cursor is used to retrieve the auto-generated project ID.\n\nInside the project loop, another `for` loop iterates over the folders in each project. For each folder, an SQL statement is executed to insert the folder name and the project ID into the \"folders\" table. The `lastrowid` attribute is used to retrieve the auto-generated folder ID.\n\nInside the folder loop, another `for` loop iterates over the files in each folder. For each file, an SQL statement is executed to insert the file name, docstring, and folder ID into the \"files\" table. The `lastrowid` attribute is used to retrieve the auto-generated file ID.\n\nInside the file loop, another `for` loop iterates over the functions and classes in each file. For each function or class, an SQL statement is executed to insert the function or class name, nl_description, docstring, ast_output, source_code, and file ID into the \"functions_classes\" table.\n\nFinally, the changes made to the database are committed using the `commit` method of the connection object.\n\nIn summary, this function reads JSON data from a file, extracts information from the JSON data, and inserts it into an SQLite database using SQL statements.",
            "docstring": "Parse JSON data and insert it into the SQLite database.\n\nArgs:\n    conn (sqlite3.Connection): Connection object to the SQLite database.\n    json_file_path (str): Path to the JSON file containing the data.",
            "ast_output": "FunctionDef(name='parse_json_insert_data', args=arguments(posonlyargs=[], args=[arg(arg='conn'), arg(arg='json_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse JSON data and insert it into the SQLite database.\\n\\n    Args:\\n        conn (sqlite3.Connection): Connection object to the SQLite database.\\n        json_file_path (str): Path to the JSON file containing the data.\\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='project_name', ctx=Store()), Name(id='folders', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO projects(name) VALUES(?)'), Tuple(elts=[Name(id='project_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='project_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='folder_name', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='folders', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO folders(name, project_id) VALUES(?, ?)'), Tuple(elts=[Name(id='folder_name', ctx=Load()), Name(id='project_id', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='folder_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='file_name', ctx=Store()), Name(id='file_contents', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='files', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='docstring')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO files(name, docstring, folder_id) VALUES(?, ?, ?)'), Tuple(elts=[Name(id='file_name', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='folder_id', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='function_name', ctx=Store()), Name(id='function_contents', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='file_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='functions_and_classes'), Dict(keys=[], values=[])], keywords=[]), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='nl_description', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='nl_description')], keywords=[])), Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='docstring')], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='ast_output')], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='source_code')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n                        INSERT INTO functions_classes(name, nl_description, docstring, ast_output, source_code, file_id) \\n                        VALUES(?, ?, ?, ?, ?, ?)\\n                        '), Tuple(elts=[Name(id='function_name', ctx=Load()), Name(id='nl_description', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load()), Name(id='file_id', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='commit', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef parse_json_insert_data(conn, json_file_path):\n    '\\n    Parse JSON data and insert it into the SQLite database.\\n\\n    Args:\\n        conn (sqlite3.Connection): Connection object to the SQLite database.\\n        json_file_path (str): Path to the JSON file containing the data.\\n    '\n    with open(json_file_path, 'r') as f:\n        data = json.load(f)\n    cursor = conn.cursor()\n    for (project_name, folders) in data.items():\n        cursor.execute('INSERT INTO projects(name) VALUES(?)', (project_name,))\n        project_id = cursor.lastrowid\n        for (folder_name, files) in folders.items():\n            cursor.execute('INSERT INTO folders(name, project_id) VALUES(?, ?)', (folder_name, project_id))\n            folder_id = cursor.lastrowid\n            for (file_name, file_contents) in files.items():\n                docstring = file_contents.get('docstring')\n                cursor.execute('INSERT INTO files(name, docstring, folder_id) VALUES(?, ?, ?)', (file_name, docstring, folder_id))\n                file_id = cursor.lastrowid\n                for (function_name, function_contents) in file_contents.get('functions_and_classes', {}).items():\n                    nl_description = function_contents.get('nl_description')\n                    docstring = function_contents.get('docstring')\n                    ast_output = function_contents.get('ast_output')\n                    source_code = function_contents.get('source_code')\n                    cursor.execute('\\n                        INSERT INTO functions_classes(name, nl_description, docstring, ast_output, source_code, file_id) \\n                        VALUES(?, ?, ?, ?, ?, ?)\\n                        ', (function_name, nl_description, docstring, ast_output, source_code, file_id))\n    conn.commit()\n"
          },
          "query_function_class": {
            "nl_description": "This code defines a function called `query_function_class` that queries a function or class from an SQLite database. The function takes in several arguments: `conn` (a connection object to the SQLite database), `project_name` (the name of the project), `folder_name` (the name of the folder), `file_name` (the name of the file), and `function_class_name` (the name of the function or class).\n\nInside the function, a cursor object is created using the connection object. The cursor then executes a SQL query using the `execute` method. The query selects the name, nl_description, docstring, ast_output, and source_code columns from the functions_classes table, joining it with the files, folders, and projects tables based on their respective foreign keys. The query also includes several conditions using the WHERE clause to filter the results based on the provided function_class_name, file_name, folder_name, and project_name.\n\nThe results of the query are fetched using the `fetchall` method and stored in the `rows` variable. Finally, a loop iterates over each row in `rows` and prints the row to the console.",
            "docstring": "Query a function or class from the SQLite database.\n\nArgs:\n    conn (sqlite3.Connection): Connection object to the SQLite database.\n    project_name (str): Name of the project.\n    folder_name (str): Name of the folder.\n    file_name (str): Name of the file.\n    function_class_name (str): Name of the function or class.",
            "ast_output": "FunctionDef(name='query_function_class', args=arguments(posonlyargs=[], args=[arg(arg='conn'), arg(arg='project_name'), arg(arg='folder_name'), arg(arg='file_name'), arg(arg='function_class_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Query a function or class from the SQLite database.\\n\\n    Args:\\n        conn (sqlite3.Connection): Connection object to the SQLite database.\\n        project_name (str): Name of the project.\\n        folder_name (str): Name of the folder.\\n        file_name (str): Name of the file.\\n        function_class_name (str): Name of the function or class.\\n    ')), Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n        SELECT \\n            f_c.name, \\n            f_c.nl_description, \\n            f_c.docstring, \\n            f_c.ast_output, \\n            f_c.source_code \\n        FROM functions_classes f_c\\n        JOIN files f ON f_c.file_id = f.id\\n        JOIN folders fo ON f.folder_id = fo.id\\n        JOIN projects p ON fo.project_id = p.id\\n        WHERE \\n            f_c.name = ? AND\\n            f.name = ? AND\\n            fo.name = ? AND\\n            p.name = ?\\n        '), Tuple(elts=[Name(id='function_class_name', ctx=Load()), Name(id='file_name', ctx=Load()), Name(id='folder_name', ctx=Load()), Name(id='project_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='rows', ctx=Store())], value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='fetchall', ctx=Load()), args=[], keywords=[])), For(target=Name(id='row', ctx=Store()), iter=Name(id='rows', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef query_function_class(conn, project_name, folder_name, file_name, function_class_name):\n    '\\n    Query a function or class from the SQLite database.\\n\\n    Args:\\n        conn (sqlite3.Connection): Connection object to the SQLite database.\\n        project_name (str): Name of the project.\\n        folder_name (str): Name of the folder.\\n        file_name (str): Name of the file.\\n        function_class_name (str): Name of the function or class.\\n    '\n    cursor = conn.cursor()\n    cursor.execute('\\n        SELECT \\n            f_c.name, \\n            f_c.nl_description, \\n            f_c.docstring, \\n            f_c.ast_output, \\n            f_c.source_code \\n        FROM functions_classes f_c\\n        JOIN files f ON f_c.file_id = f.id\\n        JOIN folders fo ON f.folder_id = fo.id\\n        JOIN projects p ON fo.project_id = p.id\\n        WHERE \\n            f_c.name = ? AND\\n            f.name = ? AND\\n            fo.name = ? AND\\n            p.name = ?\\n        ', (function_class_name, file_name, folder_name, project_name))\n    rows = cursor.fetchall()\n    for row in rows:\n        print(row)\n"
          },
          "db_gen": {
            "nl_description": "A function called `db_gen` is defined. This function takes two arguments: `json_file_path` (a string representing the path to a JSON file) and `db_file_path` (a string representing the path to a SQLite database file). \n\nInside the function, a connection to the SQLite database is created using the `create_connection` function. If the connection is not `None`, the function proceeds to call the `create_tables` function to create tables in the database and then calls the `parse_json_insert_data` function to parse the JSON file and insert the data into the database using the connection.",
            "docstring": "Generate a SQLite database from a JSON file.\n\nArgs:\n    json_file_path (str): Path to the JSON file.\n    db_file_path (str): Path to the SQLite database file.",
            "ast_output": "FunctionDef(name='db_gen', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Generate a SQLite database from a JSON file.\\n\\n    Args:\\n        json_file_path (str): Path to the JSON file.\\n        db_file_path (str): Path to the SQLite database file.\\n    ')), Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Name(id='create_connection', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='conn', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='create_tables', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='parse_json_insert_data', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='json_file_path', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef db_gen(json_file_path, db_file_path):\n    '\\n    Generate a SQLite database from a JSON file.\\n\\n    Args:\\n        json_file_path (str): Path to the JSON file.\\n        db_file_path (str): Path to the SQLite database file.\\n    '\n    conn = create_connection(db_file_path)\n    if (conn is not None):\n        create_tables(conn)\n        parse_json_insert_data(conn, json_file_path)\n"
          },
          "test_db_gen": {
            "nl_description": "This code defines a function called `test_db_gen` that tests the generation of a SQLite database from a JSON file. The function takes two arguments: `json_file_path` (a string representing the path to the JSON file) and `db_file_path` (a string representing the path to the SQLite database file).\n\nInside the function, it creates a connection to the SQLite database using the `create_connection` function. If the connection is not `None`, it proceeds to call three other functions: `create_tables`, `parse_json_insert_data`, and `query_function_class`. These functions are not defined in the given code snippet, so their functionality is unknown.",
            "docstring": "Test the generation of a SQLite database from a JSON file.\n\nArgs:\n    json_file_path (str): Path to the JSON file.\n    db_file_path (str): Path to the SQLite database file.",
            "ast_output": "FunctionDef(name='test_db_gen', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Test the generation of a SQLite database from a JSON file.\\n\\n    Args:\\n        json_file_path (str): Path to the JSON file.\\n        db_file_path (str): Path to the SQLite database file.\\n    ')), Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Name(id='create_connection', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='conn', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='create_tables', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='parse_json_insert_data', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='json_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='query_function_class', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='codebase_assistant'), Constant(value='src'), Constant(value='parser'), Constant(value='extract_info')], keywords=[]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef test_db_gen(json_file_path, db_file_path):\n    '\\n    Test the generation of a SQLite database from a JSON file.\\n\\n    Args:\\n        json_file_path (str): Path to the JSON file.\\n        db_file_path (str): Path to the SQLite database file.\\n    '\n    conn = create_connection(db_file_path)\n    if (conn is not None):\n        create_tables(conn)\n        parse_json_insert_data(conn, json_file_path)\n        query_function_class(conn, 'codebase_assistant', 'src', 'parser', 'extract_info')\n"
          }
        }
      },
      "gpt_funcs": {
        "docstring": null,
        "functions_and_classes": {
          "code_to_nl": {
            "nl_description": "This is a Python function called `code_to_nl` that takes in three arguments: `input_content`, `model_temperature`, and `model`. \n\nInside the function, there is a variable `system_message` that is a dictionary containing information about the AI system. It has two key-value pairs: `role` with the value `'system'` and `content` with a long string explaining the purpose of the AI.\n\nThere is also a variable `user_message` that is a dictionary containing information about the user's input. It has two key-value pairs: `role` with the value `'user'` and `content` with the value of the `input_content` argument.\n\nThe function then makes a call to the OpenAI API using the `openai.ChatCompletion.create` method. It passes in the `model`, `messages`, and `temperature` arguments. The `model` argument specifies the model to use (default is `'gpt-3.5-turbo'`). The `messages` argument is a list containing the `system_message` and `user_message` dictionaries. The `temperature` argument controls the randomness of the AI's response (default is `0.1`).\n\nFinally, the function returns the generated response from the API call, which is extracted from the `response` object using dictionary indexing.",
            "docstring": null,
            "ast_output": "FunctionDef(name='code_to_nl', args=arguments(posonlyargs=[], args=[arg(arg='input_content'), arg(arg='model_temperature'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.1), Constant(value='gpt-3.5-turbo')]), body=[Assign(targets=[Name(id='system_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Constant(value=\"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\")])), Assign(targets=[Name(id='user_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='input_content', ctx=Load())])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='messages', value=List(elts=[Name(id='system_message', ctx=Load()), Name(id='user_message', ctx=Load())], ctx=Load())), keyword(arg='temperature', value=Name(id='model_temperature', ctx=Load()))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef code_to_nl(input_content, model_temperature=0.1, model='gpt-3.5-turbo'):\n    system_message = {'role': 'system', 'content': \"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\"}\n    user_message = {'role': 'user', 'content': input_content}\n    response = openai.ChatCompletion.create(model=model, messages=[system_message, user_message], temperature=model_temperature)\n    return response['choices'][0]['message']['content']\n"
          }
        }
      },
      "code_parser": {
        "docstring": null,
        "functions_and_classes": {
          "extract_info": {
            "nl_description": "This code defines a function called `extract_info` that takes in a parameter called `node`. The function's purpose is to extract docstrings and AST (Abstract Syntax Tree) dumps for functions and classes.\n\nThe function first checks if the `node` parameter is an instance of either `ast.FunctionDef` or `ast.ClassDef`. If it is, the function proceeds to extract the docstring, AST output, source code, and a natural language description of the code.\n\nThe docstring is obtained using the `ast.get_docstring` function, which retrieves the docstring of the given `node`. The AST output is obtained by calling `ast.dump` on the `node`, which returns a string representation of the AST.\n\nThe source code is obtained by calling `astunparse.unparse` on the `node`, which converts the AST back into source code. Finally, the source code is passed to a function called `code_to_nl` to generate a natural language description of the code.\n\nThe function then returns a dictionary containing the natural language description (`nl_description`), docstring, AST output, and source code. If the `node` is not an instance of `ast.FunctionDef` or `ast.ClassDef`, the function returns `None`.",
            "docstring": "Extract docstrings and AST dumps for functions and classes.\n\nArgs:\n    node (ast.AST): An AST node.\n\nReturns:\n    dict: A dictionary containing natural language description, docstring, AST output, and source code\n          if the node is an instance of ast.FunctionDef or ast.ClassDef; None otherwise.",
            "ast_output": "FunctionDef(name='extract_info', args=arguments(posonlyargs=[], args=[arg(arg='node')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Extract docstrings and AST dumps for functions and classes.\\n\\n    Args:\\n        node (ast.AST): An AST node.\\n\\n    Returns:\\n        dict: A dictionary containing natural language description, docstring, AST output, and source code\\n              if the node is an instance of ast.FunctionDef or ast.ClassDef; None otherwise.\\n    ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='ast', ctx=Load()), attr='FunctionDef', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='ClassDef', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='astunparse', ctx=Load()), attr='unparse', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nl_description', ctx=Store())], value=Call(func=Name(id='code_to_nl', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Return(value=Dict(keys=[Constant(value='nl_description'), Constant(value='docstring'), Constant(value='ast_output'), Constant(value='source_code')], values=[Name(id='nl_description', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load())]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef extract_info(node):\n    '\\n    Extract docstrings and AST dumps for functions and classes.\\n\\n    Args:\\n        node (ast.AST): An AST node.\\n\\n    Returns:\\n        dict: A dictionary containing natural language description, docstring, AST output, and source code\\n              if the node is an instance of ast.FunctionDef or ast.ClassDef; None otherwise.\\n    '\n    if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n        docstring = ast.get_docstring(node)\n        ast_output = ast.dump(node)\n        source_code = astunparse.unparse(node)\n        nl_description = code_to_nl(source_code)\n        return {'nl_description': nl_description, 'docstring': docstring, 'ast_output': ast_output, 'source_code': source_code}\n"
          },
          "parse_file": {
            "nl_description": "This code defines a function called `parse_file` that takes a `file_path` as an argument. The function reads the contents of the file specified by `file_path` and stores it in the `source_code` variable. \n\nThe `ast.parse` function is then used to parse the `source_code` and create an abstract syntax tree (AST) representation of the code. The `ast.get_docstring` function is used to extract the docstring of the module.\n\nThe code then creates a dictionary called `functions_and_classes` that will store information about the functions and classes in the module. It iterates over the `body` of the module and for each node that represents a function or class, it calls a function called `extract_info` to extract information about that node. If `extract_info` returns a non-None value, it adds an entry to the `functions_and_classes` dictionary with the name of the function or class as the key and the extracted information as the value.\n\nFinally, the function returns a dictionary with two keys: 'docstring' and 'functions_and_classes'. The value associated with the 'docstring' key is the module docstring extracted earlier, and the value associated with the 'functions_and_classes' key is the dictionary containing information about the functions and classes in the module.",
            "docstring": "Parse a Python file.\n\nArgs:\n    file_path (str): The path to the Python file.\n\nReturns:\n    dict: A dictionary containing the module docstring and a dictionary of the functions and classes.",
            "ast_output": "FunctionDef(name='parse_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse a Python file.\\n\\n    Args:\\n        file_path (str): The path to the Python file.\\n\\n    Returns:\\n        dict: A dictionary containing the module docstring and a dictionary of the functions and classes.\\n    ')), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Assign(targets=[Name(id='functions_and_classes', ctx=Store())], value=DictComp(key=Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load()), value=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='node', ctx=Store()), iter=Attribute(value=Name(id='module', ctx=Load()), attr='body', ctx=Load()), ifs=[Compare(left=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[]), ops=[IsNot()], comparators=[Constant(value=None)])], is_async=0)])), Return(value=Dict(keys=[Constant(value='docstring'), Constant(value='functions_and_classes')], values=[Name(id='module_docstring', ctx=Load()), Name(id='functions_and_classes', ctx=Load())]))], decorator_list=[])",
            "source_code": "\n\ndef parse_file(file_path):\n    '\\n    Parse a Python file.\\n\\n    Args:\\n        file_path (str): The path to the Python file.\\n\\n    Returns:\\n        dict: A dictionary containing the module docstring and a dictionary of the functions and classes.\\n    '\n    with open(file_path, 'r') as file:\n        source_code = file.read()\n    module = ast.parse(source_code)\n    module_docstring = ast.get_docstring(module)\n    functions_and_classes = {node.name: extract_info(node) for node in module.body if (extract_info(node) is not None)}\n    return {'docstring': module_docstring, 'functions_and_classes': functions_and_classes}\n"
          },
          "parse_directory": {
            "nl_description": "This code defines a function called `parse_directory` that takes a `directory_path` as an argument. The function parses the files in the specified directory and returns a dictionary of the parsed modules.\n\nInside the function, a dictionary called `modules` is created. The keys of this dictionary are the filenames in the directory with the file extension removed, and the values are the result of calling the `parse_file` function on each file in the directory. The `parse_file` function is not defined in this code snippet.\n\nThe dictionary comprehension is used to iterate over the filenames in the directory using the `os.listdir` function. Only filenames that end with the `.py` extension are considered. The `os.path.splitext` function is used to remove the file extension from each filename.\n\nFinally, the `modules` dictionary is returned by the `parse_directory` function.",
            "docstring": "Parse a directory.\n\nArgs:\n    directory_path (str): The path to the directory.\n\nReturns:\n    dict: A dictionary of the modules parsed from the directory.",
            "ast_output": "FunctionDef(name='parse_directory', args=arguments(posonlyargs=[], args=[arg(arg='directory_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse a directory.\\n\\n    Args:\\n        directory_path (str): The path to the directory.\\n\\n    Returns:\\n        dict: A dictionary of the modules parsed from the directory.\\n    ')), Assign(targets=[Name(id='modules', ctx=Store())], value=DictComp(key=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()), value=Call(func=Name(id='parse_file', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='directory_path', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='filename', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='directory_path', ctx=Load())], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.py')], keywords=[])], is_async=0)])), Return(value=Name(id='modules', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_directory(directory_path):\n    '\\n    Parse a directory.\\n\\n    Args:\\n        directory_path (str): The path to the directory.\\n\\n    Returns:\\n        dict: A dictionary of the modules parsed from the directory.\\n    '\n    modules = {os.path.splitext(filename)[0]: parse_file(os.path.join(directory_path, filename)) for filename in os.listdir(directory_path) if filename.endswith('.py')}\n    return modules\n"
          },
          "parse_codebase": {
            "nl_description": "A Python function called parse_codebase is defined. This function checks if a workspace exists, prompts the user for the project folder name and directory location, creates a JSON file with this information, and creates a SQLite database from the JSON file. The function returns the path to the database file.\n\nInside the function, a variable named workspace is assigned the value 'gpt_workspace'. The code then checks if the workspace directory does not exist using the os.path.exists() function. If the directory does not exist, it creates the directory using the os.mkdir() function.\n\nThe code prompts the user for the project folder name and directory location using the input() function and assigns the values to the variables project_folder_name and directory_location, respectively.\n\nThe code then calls the parse_directory() function passing the directory_location as an argument and assigns the returned value to the variable modules.\n\nA dictionary named data is created with the project_folder_name as the key and a nested dictionary as the value. The nested dictionary has the directory_location as the key and the modules as the value.\n\nThe code creates a JSON filename using string formatting with the workspace, project_folder_name, and directory_location variables. It opens the file with the specified filename in write mode using the open() function and assigns the file object to the variable file. It then uses the json.dump() function to write the data dictionary to the file in a formatted manner with an indentation level of 2.\n\nThe code creates a database filename using string formatting with the workspace, project_folder_name, and directory_location variables. It calls the create_db() function passing the json_filename and db_filename as arguments.\n\nFinally, the function returns the db_filename variable.",
            "docstring": "Parse a codebase.\n\nThis function checks if a workspace exists, prompts the user for the project folder name and\ndirectory location, creates a JSON file with this information, and creates a SQLite database from\nthe JSON file.\n\nReturns:\n    str: The path to the database file.",
            "ast_output": "FunctionDef(name='parse_codebase', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\\n    Parse a codebase.\\n\\n    This function checks if a workspace exists, prompts the user for the project folder name and\\n    directory location, creates a JSON file with this information, and creates a SQLite database from\\n    the JSON file.\\n\\n    Returns:\\n        str: The path to the database file.\\n    ')), Assign(targets=[Name(id='workspace', ctx=Store())], value=Constant(value='gpt_workspace')), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='workspace', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='mkdir', ctx=Load()), args=[Name(id='workspace', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='project_folder_name', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Project folder name: ')], keywords=[])), Assign(targets=[Name(id='directory_location', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Directory location: ')], keywords=[])), Assign(targets=[Name(id='modules', ctx=Store())], value=Call(func=Name(id='parse_directory', ctx=Load()), args=[Name(id='directory_location', ctx=Load())], keywords=[])), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Name(id='project_folder_name', ctx=Load())], values=[Dict(keys=[Name(id='directory_location', ctx=Load())], values=[Name(id='modules', ctx=Load())])])), Assign(targets=[Name(id='json_filename', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='workspace', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.json')])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_filename', ctx=Load()), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=2))]))]), Assign(targets=[Name(id='db_filename', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='workspace', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.db')])), Expr(value=Call(func=Name(id='create_db', ctx=Load()), args=[Name(id='json_filename', ctx=Load()), Name(id='db_filename', ctx=Load())], keywords=[])), Return(value=Name(id='db_filename', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_codebase():\n    '\\n    Parse a codebase.\\n\\n    This function checks if a workspace exists, prompts the user for the project folder name and\\n    directory location, creates a JSON file with this information, and creates a SQLite database from\\n    the JSON file.\\n\\n    Returns:\\n        str: The path to the database file.\\n    '\n    workspace = 'gpt_workspace'\n    if (not os.path.exists(workspace)):\n        os.mkdir(workspace)\n    project_folder_name = input('Project folder name: ')\n    directory_location = input('Directory location: ')\n    modules = parse_directory(directory_location)\n    data = {project_folder_name: {directory_location: modules}}\n    json_filename = f'{workspace}/{project_folder_name}-{directory_location}_info.json'\n    with open(json_filename, 'w') as file:\n        json.dump(data, file, indent=2)\n    db_filename = f'{workspace}/{project_folder_name}-{directory_location}_info.db'\n    create_db(json_filename, db_filename)\n    return db_filename\n"
          }
        }
      },
      "__main__": {
        "docstring": null,
        "functions_and_classes": {
          "main": {
            "nl_description": "A Python function called main is defined. When the function is called, it performs the following steps:\n1. It calls the function parse_codebase and assigns the returned value to the variable db_path.\n2. It prompts the user to enter a query by displaying the message 'Query: '.\n3. It reads the user's input and assigns it to the variable query.\n4. It calls the function query_codebase with the arguments db_path and query, and assigns the returned value to the variable response.\n5. It returns the value of response.",
            "docstring": null,
            "ast_output": "FunctionDef(name='main', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='db_path', ctx=Store())], value=Call(func=Name(id='parse_codebase', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='query', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Query: ')], keywords=[])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='query_codebase', ctx=Load()), args=[Name(id='db_path', ctx=Load()), Name(id='query', ctx=Load())], keywords=[])), Return(value=Name(id='response', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef main():\n    db_path = parse_codebase()\n    query = input('Query: ')\n    response = query_codebase(db_path, query)\n    return response\n"
          }
        }
      },
      "semantic_search": {
        "docstring": null,
        "functions_and_classes": {
          "calculate_similarities": {
            "nl_description": "A Python function called calculate_similarities is defined. This function takes two parameters: past_vectors and user_vector. It calculates the cosine similarity between the user_vector and each vector in past_vectors using the cosine_similarity function. The result is returned as a list, and the first element of the list is returned.",
            "docstring": null,
            "ast_output": "FunctionDef(name='calculate_similarities', args=arguments(posonlyargs=[], args=[arg(arg='past_vectors'), arg(arg='user_vector')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='cosine_similarity', ctx=Load()), args=[List(elts=[Name(id='user_vector', ctx=Load())], ctx=Load()), Name(id='past_vectors', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef calculate_similarities(past_vectors, user_vector):\n    return cosine_similarity([user_vector], past_vectors)[0]\n"
          },
          "get_most_similar": {
            "nl_description": "A Python function called get_most_similar is defined. This function takes two parameters: similarities and k. \n\nInside the function, it uses the np.argsort() function from the numpy library to sort the similarities array in ascending order and returns the indices of the sorted array. The last k indices of the sorted array are selected using the slicing notation [-k:]. \n\nFinally, the function returns the selected indices in reverse order using the slicing notation [::-1].",
            "docstring": null,
            "ast_output": "FunctionDef(name='get_most_similar', args=arguments(posonlyargs=[], args=[arg(arg='similarities'), arg(arg='k')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='most_similar_indices', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='argsort', ctx=Load()), args=[Name(id='similarities', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))), ctx=Load())), Return(value=Subscript(value=Name(id='most_similar_indices', ctx=Load()), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef get_most_similar(similarities, k):\n    most_similar_indices = np.argsort(similarities)[(- k):]\n    return most_similar_indices[::(- 1)]\n"
          },
          "embed_sentences": {
            "nl_description": "A Python function called embed_sentences is defined. This function takes in a list of sentences as input. It then uses a list comprehension to iterate over each sentence in the input list and calls another function called embed_sentence on each sentence. The result is a new list containing the embedded representation of each sentence. This new list is then returned as the output of the function.",
            "docstring": null,
            "ast_output": "FunctionDef(name='embed_sentences', args=arguments(posonlyargs=[], args=[arg(arg='sentences')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Call(func=Name(id='embed_sentence', ctx=Load()), args=[Name(id='sentence', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='sentence', ctx=Store()), iter=Name(id='sentences', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[])",
            "source_code": "\n\ndef embed_sentences(sentences):\n    return [embed_sentence(sentence) for sentence in sentences]\n"
          },
          "embed_sentence": {
            "nl_description": "This code defines a function called `embed_sentence` that takes a parameter called `sentence`. Inside the function, it uses the OpenAI API to create an embedding for the input sentence using the `text-embedding-ada-002` model. The resulting embedding is then returned by the function.",
            "docstring": null,
            "ast_output": "FunctionDef(name='embed_sentence', args=arguments(posonlyargs=[], args=[arg(arg='sentence')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='Embedding', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='input', value=Name(id='sentence', ctx=Load())), keyword(arg='model', value=Constant(value='text-embedding-ada-002'))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='data'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='embedding'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef embed_sentence(sentence):\n    response = openai.Embedding.create(input=sentence, model='text-embedding-ada-002')\n    return response['data'][0]['embedding']\n"
          },
          "save_conversation_history": {
            "nl_description": "This code defines a function called `save_conversation_history` that takes two parameters: `user_input` and `chatbot_response`. \n\nInside the function, it establishes a connection to a SQLite database named `chat_history.db` using the `sqlite3.connect()` function and assigns the connection object to the variable `conn`. \n\nIt then creates a cursor object using `conn.cursor()` and assigns it to the variable `cur`. \n\nThe code then executes a SQL query using `cur.execute()` to create a table named `chat_history` if it does not already exist. The table has two columns: `user_input` and `chatbot_response`, both of type TEXT. \n\nNext, the code executes another SQL query to insert the `user_input` and `chatbot_response` values into the `chat_history` table using string interpolation to dynamically insert the values into the query. \n\nAfter that, it commits the changes to the database using `conn.commit()` and closes the connection using `conn.close()`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='save_conversation_history', args=arguments(posonlyargs=[], args=[arg(arg='user_input'), arg(arg='chatbot_response')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Constant(value='chat_history.db')], keywords=[])), Assign(targets=[Name(id='cur', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='CREATE TABLE IF NOT EXISTS chat_history\\n                (user_input TEXT, chatbot_response TEXT)')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='execute', ctx=Load()), args=[JoinedStr(values=[Constant(value='INSERT INTO chat_history VALUES (?, ?)')]), Tuple(elts=[Name(id='user_input', ctx=Load()), Name(id='chatbot_response', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='commit', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef save_conversation_history(user_input, chatbot_response):\n    conn = sqlite3.connect('chat_history.db')\n    cur = conn.cursor()\n    cur.execute('CREATE TABLE IF NOT EXISTS chat_history\\n                (user_input TEXT, chatbot_response TEXT)')\n    cur.execute(f'INSERT INTO chat_history VALUES (?, ?)', (user_input, chatbot_response))\n    conn.commit()\n    conn.close()\n"
          },
          "get_past_conversations": {
            "nl_description": "This code defines a function called `get_past_conversations` that takes a parameter `db_file_path`. \n\nInside the function, it connects to a SQLite database using the `sqlite3.connect` function and assigns the connection to the variable `conn`. It then creates a cursor object using `conn.cursor()` and assigns it to the variable `cur`.\n\nThe code then executes a SQL query using the `cur.execute` method. The query selects the `name`, `nl_description`, and `source_code` columns from the `functions_classes` table. The query is formatted with newline characters for readability.\n\nThe results of the query are fetched using the `cur.fetchall()` method and assigned to the variable `past_conversations`.\n\nFinally, the connection to the database is closed using `conn.close()`, and the `past_conversations` variable is returned.",
            "docstring": null,
            "ast_output": "FunctionDef(name='get_past_conversations', args=arguments(posonlyargs=[], args=[arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cur', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n        SELECT \\n            name, \\n            nl_description,\\n            source_code\\n        FROM functions_classes\\n    ')], keywords=[])), Assign(targets=[Name(id='past_conversations', ctx=Store())], value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='fetchall', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='past_conversations', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef get_past_conversations(db_file_path):\n    conn = sqlite3.connect(db_file_path)\n    cur = conn.cursor()\n    cur.execute('\\n        SELECT \\n            name, \\n            nl_description,\\n            source_code\\n        FROM functions_classes\\n    ')\n    past_conversations = cur.fetchall()\n    conn.close()\n    return past_conversations\n"
          },
          "semantic_search": {
            "nl_description": "This code defines a function called `semantic_search` that takes two arguments: `past_conversations` and `user_input`. \n\nInside the function, it creates a list called `past_sentences` by extracting the second element of each tuple in the `past_conversations` list. \n\nThen, it calls the `embed_sentences` function, passing `past_sentences` as an argument, and assigns the result to the variable `past_vectors`. \n\nNext, it calls the `embed_sentence` function, passing `user_input` as an argument, and assigns the result to the variable `user_vector`. \n\nAfter that, it calls the `calculate_similarities` function, passing `past_vectors` and `user_vector` as arguments, and assigns the result to the variable `similarities`. \n\nThen, it calls the `get_most_similar` function, passing `similarities` and the number 1 as arguments, and assigns the result to the variable `most_similar_indices`. \n\nNext, it creates a list called `most_similar_sentences` by extracting the elements from `past_sentences` at the indices specified by `most_similar_indices`. \n\nFinally, it returns a tuple containing `most_similar_sentences` and `most_similar_indices`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='semantic_search', args=arguments(posonlyargs=[], args=[arg(arg='past_conversations'), arg(arg='user_input')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='past_sentences', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='conv', ctx=Load()), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='conv', ctx=Store()), iter=Name(id='past_conversations', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='past_vectors', ctx=Store())], value=Call(func=Name(id='embed_sentences', ctx=Load()), args=[Name(id='past_sentences', ctx=Load())], keywords=[])), Assign(targets=[Name(id='user_vector', ctx=Store())], value=Call(func=Name(id='embed_sentence', ctx=Load()), args=[Name(id='user_input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='similarities', ctx=Store())], value=Call(func=Name(id='calculate_similarities', ctx=Load()), args=[Name(id='past_vectors', ctx=Load()), Name(id='user_vector', ctx=Load())], keywords=[])), Assign(targets=[Name(id='most_similar_indices', ctx=Store())], value=Call(func=Name(id='get_most_similar', ctx=Load()), args=[Name(id='similarities', ctx=Load()), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='most_similar_sentences', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='past_sentences', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='most_similar_indices', ctx=Load()), ifs=[], is_async=0)])), Return(value=Tuple(elts=[Name(id='most_similar_sentences', ctx=Load()), Name(id='most_similar_indices', ctx=Load())], ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef semantic_search(past_conversations, user_input):\n    past_sentences = [conv[1] for conv in past_conversations]\n    past_vectors = embed_sentences(past_sentences)\n    user_vector = embed_sentence(user_input)\n    similarities = calculate_similarities(past_vectors, user_vector)\n    most_similar_indices = get_most_similar(similarities, 1)\n    most_similar_sentences = [past_sentences[i] for i in most_similar_indices]\n    return (most_similar_sentences, most_similar_indices)\n"
          },
          "query_codebase": {
            "nl_description": "This code defines a function called `query_codebase` that takes two parameters: `db_path` and `user_input`. \n\nInside the function, it calls the `get_past_conversations` function with the `db_path` parameter to retrieve past conversations. \n\nThen, it calls the `semantic_search` function with the `past_conversations` and `user_input` parameters. The `semantic_search` function returns two values: `most_similar_sentences` and `most_similar_indicies`. \n\nNext, it assigns the first element of `most_similar_indicies` to the variable `most_similar_indicie`. \n\nThen, it retrieves the conversation at the index `most_similar_indicie` from `past_conversations` and assigns it to the variable `relevant_func`. \n\nAfter that, it joins the elements of `relevant_func` with a colon separator and assigns the result back to `relevant_func`. \n\nFinally, it returns the value of `relevant_func`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='query_codebase', args=arguments(posonlyargs=[], args=[arg(arg='db_path'), arg(arg='user_input')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='past_conversations', ctx=Store())], value=Call(func=Name(id='get_past_conversations', ctx=Load()), args=[Name(id='db_path', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='most_similar_sentences', ctx=Store()), Name(id='most_similar_indicies', ctx=Store())], ctx=Store())], value=Call(func=Name(id='semantic_search', ctx=Load()), args=[Name(id='past_conversations', ctx=Load()), Name(id='user_input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='most_similar_indicie', ctx=Store())], value=Subscript(value=Name(id='most_similar_indicies', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='relevant_func', ctx=Store())], value=Subscript(value=Name(id='past_conversations', ctx=Load()), slice=Name(id='most_similar_indicie', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='relevant_func', ctx=Store())], value=Call(func=Attribute(value=Constant(value=': '), attr='join', ctx=Load()), args=[Name(id='relevant_func', ctx=Load())], keywords=[])), Return(value=Name(id='relevant_func', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef query_codebase(db_path, user_input):\n    past_conversations = get_past_conversations(db_path)\n    (most_similar_sentences, most_similar_indicies) = semantic_search(past_conversations, user_input)\n    most_similar_indicie = most_similar_indicies[0]\n    relevant_func = past_conversations[most_similar_indicie]\n    relevant_func = ': '.join(relevant_func)\n    return relevant_func\n"
          }
        }
      }
    }
  }
}