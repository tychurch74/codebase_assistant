{
  "codebase_assistant": {
    "src": {
      "__init__": {
        "docstring": null,
        "functions_and_classes": {}
      },
      "code_gen": {
        "docstring": null,
        "functions_and_classes": {}
      },
      "db_gen": {
        "docstring": null,
        "functions_and_classes": {
          "create_connection": {
            "nl_description": "This code defines a function called `create_connection` that takes a parameter `db_file`. Inside the function, it creates a variable `conn` and sets it to `None`. Then, it tries to establish a connection to a SQLite database using the `sqlite3.connect()` function, passing `db_file` as the argument. If the connection is successfully established, it returns the connection object. If an error occurs during the connection attempt, it catches the error and prints it to the console.",
            "docstring": null,
            "ast_output": "FunctionDef(name='create_connection', args=arguments(posonlyargs=[], args=[arg(arg='db_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Constant(value=None)), Try(body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Name(id='db_file', ctx=Load())], keywords=[])), Return(value=Name(id='conn', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])",
            "source_code": "\n\ndef create_connection(db_file):\n    conn = None\n    try:\n        conn = sqlite3.connect(db_file)\n        return conn\n    except Error as e:\n        print(e)\n"
          },
          "create_tables": {
            "nl_description": "This code defines a function called `create_tables` that takes a parameter `conn`. \n\nInside the function, it tries to execute several SQL queries using the `cursor` object obtained from `conn.cursor()`. These queries create four tables: `projects`, `folders`, `files`, and `functions_classes`. Each table has its own set of columns defined.\n\nIf any error occurs during the execution of the queries, the error message is printed to the console.",
            "docstring": null,
            "ast_output": "FunctionDef(name='create_tables', args=arguments(posonlyargs=[], args=[arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE projects (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL\\n            );\\n        ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE folders (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                project_id INTEGER,\\n                FOREIGN KEY(project_id) REFERENCES projects(id)\\n            );\\n        ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE files (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                docstring TEXT,\\n                folder_id INTEGER,\\n                FOREIGN KEY(folder_id) REFERENCES folders(id)\\n            );\\n        ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE functions_classes (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                nl_description TEXT,\\n                docstring TEXT,\\n                ast_output TEXT,\\n                source_code TEXT,\\n                file_id INTEGER,\\n                FOREIGN KEY(file_id) REFERENCES files(id)\\n            );\\n        ')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])",
            "source_code": "\n\ndef create_tables(conn):\n    try:\n        cursor = conn.cursor()\n        cursor.execute('\\n            CREATE TABLE projects (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL\\n            );\\n        ')\n        cursor.execute('\\n            CREATE TABLE folders (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                project_id INTEGER,\\n                FOREIGN KEY(project_id) REFERENCES projects(id)\\n            );\\n        ')\n        cursor.execute('\\n            CREATE TABLE files (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                docstring TEXT,\\n                folder_id INTEGER,\\n                FOREIGN KEY(folder_id) REFERENCES folders(id)\\n            );\\n        ')\n        cursor.execute('\\n            CREATE TABLE functions_classes (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                nl_description TEXT,\\n                docstring TEXT,\\n                ast_output TEXT,\\n                source_code TEXT,\\n                file_id INTEGER,\\n                FOREIGN KEY(file_id) REFERENCES files(id)\\n            );\\n        ')\n    except Error as e:\n        print(e)\n"
          },
          "parse_json_insert_data": {
            "nl_description": "This code defines a function called `parse_json_insert_data` that takes two parameters: `conn` and `json_file_path`. \n\nInside the function, it opens the JSON file specified by `json_file_path` and reads its contents using the `json.load()` function. The resulting data is stored in the `data` variable.\n\nThen, it creates a cursor object using the `conn.cursor()` method.\n\nThe code then iterates over the items in the `data` dictionary using a for loop. Each item consists of a `project_name` and a `folders` dictionary.\n\nFor each project, it executes an SQL query to insert the `project_name` into the \"projects\" table using the `cursor.execute()` method. The project ID of the inserted row is obtained using `cursor.lastrowid`.\n\nNext, it iterates over the items in the `folders` dictionary. Each item consists of a `folder_name` and a `files` dictionary.\n\nFor each folder, it executes an SQL query to insert the `folder_name` and the corresponding `project_id` into the \"folders\" table.\n\nThen, it iterates over the items in the `files` dictionary. Each item consists of a `file_name` and a `file_contents` dictionary.\n\nFor each file, it executes an SQL query to insert the `file_name`, the `docstring`, and the corresponding `folder_id` into the \"files\" table.\n\nNext, it iterates over the items in the `functions_and_classes` dictionary within the `file_contents` dictionary. Each item consists of a `function_name` and a `function_contents` dictionary.\n\nFor each function or class, it retrieves the `nl_description`, `docstring`, `ast_output`, and `source_code` from the `function_contents` dictionary.\n\nThen, it executes an SQL query to insert the `function_name`, `nl_description`, `docstring`, `ast_output`, `source_code`, and the corresponding `file_id` into the \"functions_classes\" table.\n\nFinally, it commits the changes made to the database using `conn.commit()`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_json_insert_data', args=arguments(posonlyargs=[], args=[arg(arg='conn'), arg(arg='json_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='project_name', ctx=Store()), Name(id='folders', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO projects(name) VALUES(?)'), Tuple(elts=[Name(id='project_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='project_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='folder_name', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='folders', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO folders(name, project_id) VALUES(?, ?)'), Tuple(elts=[Name(id='folder_name', ctx=Load()), Name(id='project_id', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='folder_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='file_name', ctx=Store()), Name(id='file_contents', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='files', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='docstring')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO files(name, docstring, folder_id) VALUES(?, ?, ?)'), Tuple(elts=[Name(id='file_name', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='folder_id', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='function_name', ctx=Store()), Name(id='function_contents', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='file_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='functions_and_classes'), Dict(keys=[], values=[])], keywords=[]), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='nl_description', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='nl_description')], keywords=[])), Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='docstring')], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='ast_output')], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='source_code')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n                        INSERT INTO functions_classes(name, nl_description, docstring, ast_output, source_code, file_id) \\n                        VALUES(?, ?, ?, ?, ?, ?)\\n                    '), Tuple(elts=[Name(id='function_name', ctx=Load()), Name(id='nl_description', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load()), Name(id='file_id', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='commit', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef parse_json_insert_data(conn, json_file_path):\n    with open(json_file_path, 'r') as f:\n        data = json.load(f)\n    cursor = conn.cursor()\n    for (project_name, folders) in data.items():\n        cursor.execute('INSERT INTO projects(name) VALUES(?)', (project_name,))\n        project_id = cursor.lastrowid\n        for (folder_name, files) in folders.items():\n            cursor.execute('INSERT INTO folders(name, project_id) VALUES(?, ?)', (folder_name, project_id))\n            folder_id = cursor.lastrowid\n            for (file_name, file_contents) in files.items():\n                docstring = file_contents.get('docstring')\n                cursor.execute('INSERT INTO files(name, docstring, folder_id) VALUES(?, ?, ?)', (file_name, docstring, folder_id))\n                file_id = cursor.lastrowid\n                for (function_name, function_contents) in file_contents.get('functions_and_classes', {}).items():\n                    nl_description = function_contents.get('nl_description')\n                    docstring = function_contents.get('docstring')\n                    ast_output = function_contents.get('ast_output')\n                    source_code = function_contents.get('source_code')\n                    cursor.execute('\\n                        INSERT INTO functions_classes(name, nl_description, docstring, ast_output, source_code, file_id) \\n                        VALUES(?, ?, ?, ?, ?, ?)\\n                    ', (function_name, nl_description, docstring, ast_output, source_code, file_id))\n    conn.commit()\n"
          },
          "query_function_class": {
            "nl_description": "This code defines a function called `query_function_class` that takes in several parameters: `conn`, `project_name`, `folder_name`, `file_name`, and `function_class_name`. \n\nInside the function, a cursor object is created using the `conn` parameter. The cursor is then used to execute a SQL query. The query selects several columns (`name`, `nl_description`, `docstring`, `ast_output`, `source_code`) from a table called `functions_classes`. The query also joins the `files`, `folders`, and `projects` tables based on their respective foreign keys. The join conditions are specified in the `WHERE` clause, which checks for matching values in the `name` columns of the `functions_classes`, `files`, `folders`, and `projects` tables.\n\nThe query parameters (`function_class_name`, `file_name`, `folder_name`, `project_name`) are passed as arguments to the query using a tuple.\n\nThe `cursor.fetchall()` method is then called to retrieve all the rows returned by the query. The rows are stored in the `rows` variable.\n\nFinally, a loop is used to iterate over each row in `rows`, and the `print()` function is called to print each row.",
            "docstring": null,
            "ast_output": "FunctionDef(name='query_function_class', args=arguments(posonlyargs=[], args=[arg(arg='conn'), arg(arg='project_name'), arg(arg='folder_name'), arg(arg='file_name'), arg(arg='function_class_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n        SELECT \\n            f_c.name, \\n            f_c.nl_description, \\n            f_c.docstring, \\n            f_c.ast_output, \\n            f_c.source_code \\n        FROM functions_classes f_c\\n        JOIN files f ON f_c.file_id = f.id\\n        JOIN folders fo ON f.folder_id = fo.id\\n        JOIN projects p ON fo.project_id = p.id\\n        WHERE \\n            f_c.name = ? AND\\n            f.name = ? AND\\n            fo.name = ? AND\\n            p.name = ?\\n    '), Tuple(elts=[Name(id='function_class_name', ctx=Load()), Name(id='file_name', ctx=Load()), Name(id='folder_name', ctx=Load()), Name(id='project_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='rows', ctx=Store())], value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='fetchall', ctx=Load()), args=[], keywords=[])), For(target=Name(id='row', ctx=Store()), iter=Name(id='rows', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef query_function_class(conn, project_name, folder_name, file_name, function_class_name):\n    cursor = conn.cursor()\n    cursor.execute('\\n        SELECT \\n            f_c.name, \\n            f_c.nl_description, \\n            f_c.docstring, \\n            f_c.ast_output, \\n            f_c.source_code \\n        FROM functions_classes f_c\\n        JOIN files f ON f_c.file_id = f.id\\n        JOIN folders fo ON f.folder_id = fo.id\\n        JOIN projects p ON fo.project_id = p.id\\n        WHERE \\n            f_c.name = ? AND\\n            f.name = ? AND\\n            fo.name = ? AND\\n            p.name = ?\\n    ', (function_class_name, file_name, folder_name, project_name))\n    rows = cursor.fetchall()\n    for row in rows:\n        print(row)\n"
          },
          "main": {
            "nl_description": "A Python function called main is defined. The function takes two parameters: json_file_path and db_file_path. \n\nInside the function, a connection to a database is created using the create_connection function, passing in the db_file_path parameter. \n\nThen, the create_tables function is called, passing in the connection object as a parameter. This function is responsible for creating tables in the database. \n\nFinally, the parse_json_insert_data function is called, passing in the connection object and the json_file_path parameter. This function is responsible for parsing a JSON file and inserting the data into the database.",
            "docstring": null,
            "ast_output": "FunctionDef(name='main', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Name(id='create_connection', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='create_tables', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='parse_json_insert_data', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='json_file_path', ctx=Load())], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef main(json_file_path, db_file_path):\n    conn = create_connection(db_file_path)\n    create_tables(conn)\n    parse_json_insert_data(conn, json_file_path)\n"
          },
          "test_main": {
            "nl_description": "A Python function called test_main is defined. The function takes two parameters: json_file_path and db_file_path. \n\nInside the function, a connection to a database is created using the create_connection function, passing in the db_file_path parameter. \n\nThen, the create_tables function is called, passing in the conn variable as an argument. This function is responsible for creating tables in the database. \n\nNext, the parse_json_insert_data function is called, passing in the conn variable and json_file_path parameter. This function is responsible for parsing a JSON file and inserting the data into the database. \n\nFinally, the query_function_class function is called, passing in the conn variable, as well as the strings 'codebase_assistant', 'src', 'parser', and 'extract_info'. This function is responsible for querying the database using the provided parameters.",
            "docstring": null,
            "ast_output": "FunctionDef(name='test_main', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Name(id='create_connection', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='create_tables', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='parse_json_insert_data', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='json_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='query_function_class', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='codebase_assistant'), Constant(value='src'), Constant(value='parser'), Constant(value='extract_info')], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef test_main(json_file_path, db_file_path):\n    conn = create_connection(db_file_path)\n    create_tables(conn)\n    parse_json_insert_data(conn, json_file_path)\n    query_function_class(conn, 'codebase_assistant', 'src', 'parser', 'extract_info')\n"
          }
        }
      },
      "gpt_funcs": {
        "docstring": null,
        "functions_and_classes": {
          "code_to_nl": {
            "nl_description": "This is a Python function called `code_to_nl` that takes in three arguments: `input_content`, `model_temperature`, and `model`. \n\nInside the function, there is a variable `system_message` that is a dictionary representing a system message. It has two key-value pairs: `'role'` with the value `'system'`, and `'content'` with a long string explaining the purpose of the AI.\n\nThere is also a variable `user_message` that is a dictionary representing a user message. It has two key-value pairs: `'role'` with the value `'user'`, and `'content'` with the value of the `input_content` argument passed to the function.\n\nThe function then makes a call to the OpenAI API using the `openai.ChatCompletion.create` method. It passes the `model`, `messages`, and `temperature` arguments to the method. The `model` argument specifies the model to use (defaulting to `'gpt-3.5-turbo'`), the `messages` argument is a list containing the `system_message` and `user_message` dictionaries, and the `temperature` argument specifies the randomness of the AI's response (defaulting to `0.1`).\n\nFinally, the function returns the generated response from the API call, which is extracted from the `response` object using dictionary indexing.",
            "docstring": null,
            "ast_output": "FunctionDef(name='code_to_nl', args=arguments(posonlyargs=[], args=[arg(arg='input_content'), arg(arg='model_temperature'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.1), Constant(value='gpt-3.5-turbo')]), body=[Assign(targets=[Name(id='system_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Constant(value=\"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\")])), Assign(targets=[Name(id='user_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='input_content', ctx=Load())])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='messages', value=List(elts=[Name(id='system_message', ctx=Load()), Name(id='user_message', ctx=Load())], ctx=Load())), keyword(arg='temperature', value=Name(id='model_temperature', ctx=Load()))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef code_to_nl(input_content, model_temperature=0.1, model='gpt-3.5-turbo'):\n    system_message = {'role': 'system', 'content': \"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\"}\n    user_message = {'role': 'user', 'content': input_content}\n    response = openai.ChatCompletion.create(model=model, messages=[system_message, user_message], temperature=model_temperature)\n    return response['choices'][0]['message']['content']\n"
          }
        }
      },
      "code_parser": {
        "docstring": null,
        "functions_and_classes": {
          "extract_info": {
            "nl_description": "This code defines a function called `extract_info` that takes a parameter called `node`. \n\nInside the function, it checks if the `node` is an instance of either `ast.FunctionDef` or `ast.ClassDef`. If it is, it retrieves the docstring of the `node` using the `ast.get_docstring` function, and assigns it to the variable `docstring`. \n\nIt then uses the `ast.dump` function to get a string representation of the `node` and assigns it to the variable `ast_output`. \n\nNext, it uses the `astunparse.unparse` function to get the source code of the `node` as a string and assigns it to the variable `source_code`. \n\nFinally, it calls a function called `code_to_nl` with the `source_code` as an argument to convert the source code into natural language description and assigns the result to the variable `nl_description`. \n\nThe function then returns a dictionary with the keys `'nl_description'`, `'docstring'`, `'ast_output'`, and `'source_code'`, and their corresponding values `nl_description`, `docstring`, `ast_output`, and `source_code` respectively. \n\nIf the `node` is not an instance of `ast.FunctionDef` or `ast.ClassDef`, the function returns `None`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='extract_info', args=arguments(posonlyargs=[], args=[arg(arg='node')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='ast', ctx=Load()), attr='FunctionDef', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='ClassDef', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='astunparse', ctx=Load()), attr='unparse', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nl_desription', ctx=Store())], value=Call(func=Name(id='code_to_nl', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Return(value=Dict(keys=[Constant(value='nl_description'), Constant(value='docstring'), Constant(value='ast_output'), Constant(value='source_code')], values=[Name(id='nl_desription', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load())]))], orelse=[Return(value=Constant(value=None))])], decorator_list=[])",
            "source_code": "\n\ndef extract_info(node):\n    if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n        docstring = ast.get_docstring(node)\n        ast_output = ast.dump(node)\n        source_code = astunparse.unparse(node)\n        nl_desription = code_to_nl(source_code)\n        return {'nl_description': nl_desription, 'docstring': docstring, 'ast_output': ast_output, 'source_code': source_code}\n    else:\n        return None\n"
          },
          "parse_file": {
            "nl_description": "This code defines a function called `parse_file` that takes a `file_path` as input. \n\nInside the function, it opens the file specified by `file_path` in read mode using the `open` function and assigns the file object to the variable `file`. \n\nIt then reads the contents of the file using the `read` method of the file object and assigns the result to the variable `source_code`. \n\nThe `ast.parse` function is used to parse the `source_code` and create an abstract syntax tree (AST) representation of the code. \n\nThe `ast.get_docstring` function is used to extract the docstring (if any) from the module represented by the AST and assigns it to the variable `module_docstring`. \n\nA dictionary called `functions_and_classes` is created to store information about functions and classes found in the module. \n\nThe code then iterates over the `body` attribute of the module's AST representation using a for loop. \n\nFor each node in the body, the `extract_info` function is called to extract information about the node. If the `info` is not `None`, meaning that information was successfully extracted, the node's name is used as the key in the `functions_and_classes` dictionary and the `info` is stored as the value. \n\nFinally, the function returns a dictionary containing the `module_docstring` and the `functions_and_classes` dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Assign(targets=[Name(id='functions_and_classes', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='node', ctx=Store()), iter=Attribute(value=Name(id='module', ctx=Load()), attr='body', ctx=Load()), body=[Assign(targets=[Name(id='info', ctx=Store())], value=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='info', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='functions_and_classes', ctx=Load()), slice=Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='info', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Dict(keys=[Constant(value='docstring'), Constant(value='functions_and_classes')], values=[Name(id='module_docstring', ctx=Load()), Name(id='functions_and_classes', ctx=Load())]))], decorator_list=[])",
            "source_code": "\n\ndef parse_file(file_path):\n    with open(file_path, 'r') as file:\n        source_code = file.read()\n    module = ast.parse(source_code)\n    module_docstring = ast.get_docstring(module)\n    functions_and_classes = {}\n    for node in module.body:\n        info = extract_info(node)\n        if (info is not None):\n            functions_and_classes[node.name] = info\n    return {'docstring': module_docstring, 'functions_and_classes': functions_and_classes}\n"
          },
          "parse_directory": {
            "nl_description": "This code defines a function called `parse_directory` that takes a `directory_path` as input. \n\nInside the function, an empty dictionary called `modules` is created. \n\nThen, a loop iterates over the files in the specified directory using `os.listdir(directory_path)`. \n\nFor each file, it checks if the file ends with the extension '.py' using `filename.endswith('.py')`. \n\nIf the file has the '.py' extension, it creates the full file path by joining the directory path and the filename using `os.path.join(directory_path, filename)`. \n\nIt then extracts the module name by removing the file extension using `os.path.splitext(filename)[0]`. \n\nThe code then calls a function called `parse_file` with the file path as an argument and assigns the result to the `modules` dictionary using the module name as the key. \n\nFinally, the function returns the `modules` dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_directory', args=arguments(posonlyargs=[], args=[arg(arg='directory_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='modules', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='filename', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='directory_path', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.py')], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='directory_path', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Subscript(value=Name(id='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='parse_file', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='modules', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_directory(directory_path):\n    modules = {}\n    for filename in os.listdir(directory_path):\n        if filename.endswith('.py'):\n            file_path = os.path.join(directory_path, filename)\n            module_name = os.path.splitext(filename)[0]\n            modules[module_name] = parse_file(file_path)\n    return modules\n"
          },
          "parse_codebase": {
            "nl_description": "This code defines a function called `parse_codebase`. When this function is called, it performs the following steps:\n\n1. It checks if a directory named 'gpt_workspace' exists. If it doesn't exist, it creates the directory.\n2. It prompts the user to enter a project folder name and a directory location.\n3. It calls a function called `parse_directory` and passes the directory location as an argument. The return value of this function is stored in a variable called `modules`.\n4. It creates a dictionary called `data` with the project folder name as the key and another dictionary as the value. This inner dictionary has the directory location as the key and the `modules` variable as the value.\n5. It opens a file with a name formatted as 'gpt_workspace/{project_folder_name}-{directory_location}_info.json' in write mode.\n6. It uses the `json.dump` function to write the `data` dictionary to the file in a human-readable format with an indentation level of 2.\n7. It calls a function called `create_db` and passes two arguments: the file path of the JSON file and the file path of a database file. The database file path is formatted as 'gpt_workspace/{project_folder_name}-{directory_location}_info.db'.\n8. It assigns the database file path to a variable called `db_path`.\n9. Finally, it returns the `db_path` variable.\n\nOverall, this function creates a directory, prompts the user for input, parses a directory, creates a JSON file with the parsed data, creates a database file, and returns the path of the database file.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_codebase', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Constant(value='gpt_workspace')], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='mkdir', ctx=Load()), args=[Constant(value='gpt_workspace')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='project_folder_name', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Project folder name: ')], keywords=[])), Assign(targets=[Name(id='directory_location', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Directory location: ')], keywords=[])), Assign(targets=[Name(id='modules', ctx=Store())], value=Call(func=Name(id='parse_directory', ctx=Load()), args=[Name(id='directory_location', ctx=Load())], keywords=[])), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Name(id='project_folder_name', ctx=Load())], values=[Dict(keys=[Name(id='directory_location', ctx=Load())], values=[Name(id='modules', ctx=Load())])])), With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[JoinedStr(values=[Constant(value='gpt_workspace/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.json')]), Constant(value='w')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Expr(value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='data', ctx=Load()), Name(id='file', ctx=Load())], keywords=[keyword(arg='indent', value=Constant(value=2))]))]), Expr(value=Call(func=Name(id='create_db', ctx=Load()), args=[JoinedStr(values=[Constant(value='gpt_workspace/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.json')]), JoinedStr(values=[Constant(value='gpt_workspace/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.db')])], keywords=[])), Assign(targets=[Name(id='db_path', ctx=Store())], value=JoinedStr(values=[Constant(value='gpt_workspace/'), FormattedValue(value=Name(id='project_folder_name', ctx=Load()), conversion=-1), Constant(value='-'), FormattedValue(value=Name(id='directory_location', ctx=Load()), conversion=-1), Constant(value='_info.db')])), Return(value=Name(id='db_path', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_codebase():\n    if (not os.path.exists('gpt_workspace')):\n        os.mkdir('gpt_workspace')\n    project_folder_name = input('Project folder name: ')\n    directory_location = input('Directory location: ')\n    modules = parse_directory(directory_location)\n    data = {project_folder_name: {directory_location: modules}}\n    with open(f'gpt_workspace/{project_folder_name}-{directory_location}_info.json', 'w') as file:\n        json.dump(data, file, indent=2)\n    create_db(f'gpt_workspace/{project_folder_name}-{directory_location}_info.json', f'gpt_workspace/{project_folder_name}-{directory_location}_info.db')\n    db_path = f'gpt_workspace/{project_folder_name}-{directory_location}_info.db'\n    return db_path\n"
          }
        }
      },
      "__main__": {
        "docstring": null,
        "functions_and_classes": {
          "main": {
            "nl_description": "A Python function called main is defined. When the function is called, it performs the following steps:\n\n1. It calls the function parse_codebase and assigns the returned value to the variable db_path.\n2. It prompts the user to enter a query by displaying the message 'Query: '.\n3. It reads the user's input and assigns it to the variable query.\n4. It calls the function query_codebase with the arguments db_path and query, and assigns the returned value to the variable response.\n5. It returns the value of response.",
            "docstring": null,
            "ast_output": "FunctionDef(name='main', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='db_path', ctx=Store())], value=Call(func=Name(id='parse_codebase', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='query', ctx=Store())], value=Call(func=Name(id='input', ctx=Load()), args=[Constant(value='Query: ')], keywords=[])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Name(id='query_codebase', ctx=Load()), args=[Name(id='db_path', ctx=Load()), Name(id='query', ctx=Load())], keywords=[])), Return(value=Name(id='response', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef main():\n    db_path = parse_codebase()\n    query = input('Query: ')\n    response = query_codebase(db_path, query)\n    return response\n"
          }
        }
      },
      "semantic_search": {
        "docstring": null,
        "functions_and_classes": {
          "calculate_similarities": {
            "nl_description": "A Python function called calculate_similarities is defined. This function takes two parameters: past_vectors and user_vector. It calculates the cosine similarity between the user_vector and each vector in past_vectors using the cosine_similarity function. The result is returned as a list, and the first element of the list is returned.",
            "docstring": null,
            "ast_output": "FunctionDef(name='calculate_similarities', args=arguments(posonlyargs=[], args=[arg(arg='past_vectors'), arg(arg='user_vector')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='cosine_similarity', ctx=Load()), args=[List(elts=[Name(id='user_vector', ctx=Load())], ctx=Load()), Name(id='past_vectors', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef calculate_similarities(past_vectors, user_vector):\n    return cosine_similarity([user_vector], past_vectors)[0]\n"
          },
          "get_most_similar": {
            "nl_description": "A Python function called get_most_similar is defined. This function takes two parameters: similarities and k. \n\nInside the function, it uses the np.argsort() function from the numpy library to sort the similarities array in ascending order and returns the indices of the sorted array. The last k indices of the sorted array are selected using the slicing notation [-k:]. \n\nFinally, the function returns the selected indices in reverse order using the slicing notation [::-1], which effectively reverses the order of the array.",
            "docstring": null,
            "ast_output": "FunctionDef(name='get_most_similar', args=arguments(posonlyargs=[], args=[arg(arg='similarities'), arg(arg='k')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='most_similar_indices', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='argsort', ctx=Load()), args=[Name(id='similarities', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))), ctx=Load())), Return(value=Subscript(value=Name(id='most_similar_indices', ctx=Load()), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef get_most_similar(similarities, k):\n    most_similar_indices = np.argsort(similarities)[(- k):]\n    return most_similar_indices[::(- 1)]\n"
          },
          "embed_sentences": {
            "nl_description": "A Python function called embed_sentences is defined. This function takes in a list of sentences as input. It then uses a list comprehension to iterate over each sentence in the input list and calls another function called embed_sentence on each sentence. The result is a new list containing the embedded representation of each sentence. This new list is then returned as the output of the function.",
            "docstring": null,
            "ast_output": "FunctionDef(name='embed_sentences', args=arguments(posonlyargs=[], args=[arg(arg='sentences')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=ListComp(elt=Call(func=Name(id='embed_sentence', ctx=Load()), args=[Name(id='sentence', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='sentence', ctx=Store()), iter=Name(id='sentences', ctx=Load()), ifs=[], is_async=0)]))], decorator_list=[])",
            "source_code": "\n\ndef embed_sentences(sentences):\n    return [embed_sentence(sentence) for sentence in sentences]\n"
          },
          "embed_sentence": {
            "nl_description": "This code defines a function called `embed_sentence` that takes a parameter called `sentence`. Inside the function, it uses the OpenAI API to create an embedding for the input sentence using the `text-embedding-ada-002` model. The resulting embedding is then returned by the function.",
            "docstring": null,
            "ast_output": "FunctionDef(name='embed_sentence', args=arguments(posonlyargs=[], args=[arg(arg='sentence')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='Embedding', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='input', value=Name(id='sentence', ctx=Load())), keyword(arg='model', value=Constant(value='text-embedding-ada-002'))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='data'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='embedding'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef embed_sentence(sentence):\n    response = openai.Embedding.create(input=sentence, model='text-embedding-ada-002')\n    return response['data'][0]['embedding']\n"
          },
          "save_conversation_history": {
            "nl_description": "This code defines a function called `save_conversation_history` that takes two parameters: `user_input` and `chatbot_response`. \n\nInside the function, it establishes a connection to a SQLite database named `chat_history.db` using the `sqlite3.connect()` function and assigns the connection object to the variable `conn`. \n\nThen, it creates a cursor object using the `conn.cursor()` method and assigns it to the variable `cur`. \n\nThe code then executes a SQL statement using the `cur.execute()` method to create a table named `chat_history` if it does not already exist. The table has two columns: `user_input` of type TEXT and `chatbot_response` of type TEXT. \n\nNext, it executes another SQL statement to insert the `user_input` and `chatbot_response` values into the `chat_history` table using string interpolation to dynamically insert the values into the SQL statement. \n\nAfter that, it commits the changes to the database using the `conn.commit()` method. \n\nFinally, it closes the database connection using the `conn.close()` method.",
            "docstring": null,
            "ast_output": "FunctionDef(name='save_conversation_history', args=arguments(posonlyargs=[], args=[arg(arg='user_input'), arg(arg='chatbot_response')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Constant(value='chat_history.db')], keywords=[])), Assign(targets=[Name(id='cur', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='CREATE TABLE IF NOT EXISTS chat_history\\n                (user_input TEXT, chatbot_response TEXT)')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='execute', ctx=Load()), args=[JoinedStr(values=[Constant(value='INSERT INTO chat_history VALUES (?, ?)')]), Tuple(elts=[Name(id='user_input', ctx=Load()), Name(id='chatbot_response', ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='commit', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef save_conversation_history(user_input, chatbot_response):\n    conn = sqlite3.connect('chat_history.db')\n    cur = conn.cursor()\n    cur.execute('CREATE TABLE IF NOT EXISTS chat_history\\n                (user_input TEXT, chatbot_response TEXT)')\n    cur.execute(f'INSERT INTO chat_history VALUES (?, ?)', (user_input, chatbot_response))\n    conn.commit()\n    conn.close()\n"
          },
          "get_past_conversations": {
            "nl_description": "This code defines a function called `get_past_conversations` that takes a parameter `db_file_path`. \n\nInside the function, it connects to a SQLite database using the `sqlite3.connect` function and assigns the connection to the variable `conn`. \n\nThen, it creates a cursor object using `conn.cursor()` and assigns it to the variable `cur`. \n\nNext, it executes a SQL query using the `cur.execute` method. The query selects the `name` and `nl_description` columns from the `functions_classes` table. \n\nThe result of the query is fetched using the `cur.fetchall()` method and assigned to the variable `past_conversations`. \n\nFinally, the connection to the database is closed using `conn.close()` and the `past_conversations` variable is returned.",
            "docstring": null,
            "ast_output": "FunctionDef(name='get_past_conversations', args=arguments(posonlyargs=[], args=[arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), Assign(targets=[Name(id='cur', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n        SELECT \\n            name, \\n            nl_description\\n        FROM functions_classes\\n    ')], keywords=[])), Assign(targets=[Name(id='past_conversations', ctx=Store())], value=Call(func=Attribute(value=Name(id='cur', ctx=Load()), attr='fetchall', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='past_conversations', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef get_past_conversations(db_file_path):\n    conn = sqlite3.connect(db_file_path)\n    cur = conn.cursor()\n    cur.execute('\\n        SELECT \\n            name, \\n            nl_description\\n        FROM functions_classes\\n    ')\n    past_conversations = cur.fetchall()\n    conn.close()\n    return past_conversations\n"
          },
          "semantic_search": {
            "nl_description": "This code defines a function called `semantic_search` that takes two arguments: `past_conversations` and `user_input`. \n\nInside the function, it creates a list called `past_sentences` by extracting the second element of each tuple in the `past_conversations` list. \n\nThen, it calls the `embed_sentences` function, passing `past_sentences` as an argument, and assigns the result to the variable `past_vectors`. \n\nNext, it calls the `embed_sentence` function, passing `user_input` as an argument, and assigns the result to the variable `user_vector`. \n\nAfter that, it calls the `calculate_similarities` function, passing `past_vectors` and `user_vector` as arguments, and assigns the result to the variable `similarities`. \n\nThen, it calls the `get_most_similar` function, passing `similarities` and the number 1 as arguments, and assigns the result to the variable `most_similar_indices`. \n\nNext, it creates a list called `most_similar_sentences` by extracting the elements from the `past_sentences` list at the indices specified by `most_similar_indices`. \n\nFinally, it returns a tuple containing `most_similar_sentences` and `most_similar_indices`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='semantic_search', args=arguments(posonlyargs=[], args=[arg(arg='past_conversations'), arg(arg='user_input')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='past_sentences', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='conv', ctx=Load()), slice=Constant(value=1), ctx=Load()), generators=[comprehension(target=Name(id='conv', ctx=Store()), iter=Name(id='past_conversations', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='past_vectors', ctx=Store())], value=Call(func=Name(id='embed_sentences', ctx=Load()), args=[Name(id='past_sentences', ctx=Load())], keywords=[])), Assign(targets=[Name(id='user_vector', ctx=Store())], value=Call(func=Name(id='embed_sentence', ctx=Load()), args=[Name(id='user_input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='similarities', ctx=Store())], value=Call(func=Name(id='calculate_similarities', ctx=Load()), args=[Name(id='past_vectors', ctx=Load()), Name(id='user_vector', ctx=Load())], keywords=[])), Assign(targets=[Name(id='most_similar_indices', ctx=Store())], value=Call(func=Name(id='get_most_similar', ctx=Load()), args=[Name(id='similarities', ctx=Load()), Constant(value=1)], keywords=[])), Assign(targets=[Name(id='most_similar_sentences', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='past_sentences', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Name(id='most_similar_indices', ctx=Load()), ifs=[], is_async=0)])), Return(value=Tuple(elts=[Name(id='most_similar_sentences', ctx=Load()), Name(id='most_similar_indices', ctx=Load())], ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef semantic_search(past_conversations, user_input):\n    past_sentences = [conv[1] for conv in past_conversations]\n    past_vectors = embed_sentences(past_sentences)\n    user_vector = embed_sentence(user_input)\n    similarities = calculate_similarities(past_vectors, user_vector)\n    most_similar_indices = get_most_similar(similarities, 1)\n    most_similar_sentences = [past_sentences[i] for i in most_similar_indices]\n    return (most_similar_sentences, most_similar_indices)\n"
          },
          "query_codebase": {
            "nl_description": "This code defines a function called `query_codebase` that takes two parameters: `db_path` and `user_input`. \n\nInside the function, it calls the `get_past_conversations` function with the `db_path` parameter to retrieve past conversations. \n\nThen, it calls the `semantic_search` function with the `past_conversations` and `user_input` parameters. This function returns two values: `most_similar_sentences` and `most_similar_indicies`. \n\nNext, it assigns the first element of `most_similar_indicies` to the variable `most_similar_indicie`. \n\nThen, it retrieves the conversation at the index `most_similar_indicie` from `past_conversations` and assigns it to the variable `relevant_func`. \n\nAfter that, it joins the elements of `relevant_func` with a colon and assigns the result back to `relevant_func`. \n\nFinally, it returns the value of `relevant_func`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='query_codebase', args=arguments(posonlyargs=[], args=[arg(arg='db_path'), arg(arg='user_input')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='past_conversations', ctx=Store())], value=Call(func=Name(id='get_past_conversations', ctx=Load()), args=[Name(id='db_path', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='most_similar_sentences', ctx=Store()), Name(id='most_similar_indicies', ctx=Store())], ctx=Store())], value=Call(func=Name(id='semantic_search', ctx=Load()), args=[Name(id='past_conversations', ctx=Load()), Name(id='user_input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='most_similar_indicie', ctx=Store())], value=Subscript(value=Name(id='most_similar_indicies', ctx=Load()), slice=Constant(value=0), ctx=Load())), Assign(targets=[Name(id='relevant_func', ctx=Store())], value=Subscript(value=Name(id='past_conversations', ctx=Load()), slice=Name(id='most_similar_indicie', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='relevant_func', ctx=Store())], value=Call(func=Attribute(value=Constant(value=': '), attr='join', ctx=Load()), args=[Name(id='relevant_func', ctx=Load())], keywords=[])), Return(value=Name(id='relevant_func', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef query_codebase(db_path, user_input):\n    past_conversations = get_past_conversations(db_path)\n    (most_similar_sentences, most_similar_indicies) = semantic_search(past_conversations, user_input)\n    most_similar_indicie = most_similar_indicies[0]\n    relevant_func = past_conversations[most_similar_indicie]\n    relevant_func = ': '.join(relevant_func)\n    return relevant_func\n"
          }
        }
      }
    }
  }
}