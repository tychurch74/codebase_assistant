{
  "codebase_assistant": {
    "src": {
      "code_gen": {
        "docstring": null,
        "functions_and_classes": {}
      },
      "db_gen": {
        "docstring": null,
        "functions_and_classes": {
          "create_connection": {
            "nl_description": "This code defines a function called `create_connection` that takes a parameter `db_file`. Inside the function, it creates a variable `conn` and sets it to `None`. Then, it tries to establish a connection to a SQLite database using the `sqlite3.connect()` function, passing `db_file` as an argument. If the connection is successfully established, the function returns the connection object. If an error occurs during the connection attempt, the error message is printed to the console.",
            "docstring": null,
            "ast_output": "FunctionDef(name='create_connection', args=arguments(posonlyargs=[], args=[arg(arg='db_file')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Constant(value=None)), Try(body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Attribute(value=Name(id='sqlite3', ctx=Load()), attr='connect', ctx=Load()), args=[Name(id='db_file', ctx=Load())], keywords=[])), Return(value=Name(id='conn', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])",
            "source_code": "\n\ndef create_connection(db_file):\n    conn = None\n    try:\n        conn = sqlite3.connect(db_file)\n        return conn\n    except Error as e:\n        print(e)\n"
          },
          "create_tables": {
            "nl_description": "A Python function called create_tables is defined. It takes a parameter called conn. Inside the function, there is a try-except block. \n\nIn the try block, a cursor object is created using the conn parameter. Then, several SQL queries are executed using the cursor's execute method. These queries create four tables: projects, folders, files, and functions_classes. Each table has its own set of columns with different data types and constraints. The tables are created using the CREATE TABLE statement.\n\nIn the except block, if an error occurs during the execution of the SQL queries, the error message is printed to the console.",
            "docstring": null,
            "ast_output": "FunctionDef(name='create_tables', args=arguments(posonlyargs=[], args=[arg(arg='conn')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Try(body=[Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE projects (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL\\n            );\\n        ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE folders (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                project_id INTEGER,\\n                FOREIGN KEY(project_id) REFERENCES projects(id)\\n            );\\n        ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE files (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                docstring TEXT,\\n                folder_id INTEGER,\\n                FOREIGN KEY(folder_id) REFERENCES folders(id)\\n            );\\n        ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n            CREATE TABLE functions_classes (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                nl_description TEXT,\\n                docstring TEXT,\\n                ast_output TEXT,\\n                source_code TEXT,\\n                file_id INTEGER,\\n                FOREIGN KEY(file_id) REFERENCES files(id)\\n            );\\n        ')], keywords=[]))], handlers=[ExceptHandler(type=Name(id='Error', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='e', ctx=Load())], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[])",
            "source_code": "\n\ndef create_tables(conn):\n    try:\n        cursor = conn.cursor()\n        cursor.execute('\\n            CREATE TABLE projects (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL\\n            );\\n        ')\n        cursor.execute('\\n            CREATE TABLE folders (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                project_id INTEGER,\\n                FOREIGN KEY(project_id) REFERENCES projects(id)\\n            );\\n        ')\n        cursor.execute('\\n            CREATE TABLE files (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                docstring TEXT,\\n                folder_id INTEGER,\\n                FOREIGN KEY(folder_id) REFERENCES folders(id)\\n            );\\n        ')\n        cursor.execute('\\n            CREATE TABLE functions_classes (\\n                id INTEGER PRIMARY KEY,\\n                name TEXT NOT NULL,\\n                nl_description TEXT,\\n                docstring TEXT,\\n                ast_output TEXT,\\n                source_code TEXT,\\n                file_id INTEGER,\\n                FOREIGN KEY(file_id) REFERENCES files(id)\\n            );\\n        ')\n    except Error as e:\n        print(e)\n"
          },
          "parse_json_insert_data": {
            "nl_description": "This code defines a function called `parse_json_insert_data` that takes two parameters: `conn` and `json_file_path`. \n\nInside the function, it opens the JSON file specified by `json_file_path` and reads its contents using the `json.load()` function. The resulting data is stored in the `data` variable.\n\nThen, it creates a cursor object using the `conn.cursor()` method.\n\nThe code then iterates over the items in the `data` dictionary using a for loop. Each item consists of a `project_name` and a `folders` dictionary. For each item, it executes an SQL query to insert the `project_name` into the \"projects\" table using the `cursor.execute()` method. The `project_id` is obtained using the `cursor.lastrowid` attribute.\n\nNext, it iterates over the items in the `folders` dictionary. Each item consists of a `folder_name` and a `files` dictionary. For each item, it executes an SQL query to insert the `folder_name` and `project_id` into the \"folders\" table. The `folder_id` is obtained using the `cursor.lastrowid` attribute.\n\nThen, it iterates over the items in the `files` dictionary. Each item consists of a `file_name` and a `file_contents` dictionary. For each item, it executes an SQL query to insert the `file_name`, `docstring`, and `folder_id` into the \"files\" table. The `file_id` is obtained using the `cursor.lastrowid` attribute.\n\nFinally, it iterates over the items in the `functions_and_classes` dictionary within the `file_contents` dictionary. Each item consists of a `function_name` and a `function_contents` dictionary. For each item, it executes an SQL query to insert the `function_name`, `nl_description`, `docstring`, `ast_output`, `source_code`, and `file_id` into the \"functions_classes\" table.\n\nAfter all the iterations, it commits the changes to the database using the `conn.commit()` method.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_json_insert_data', args=arguments(posonlyargs=[], args=[arg(arg='conn'), arg(arg='json_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='json_file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='f', ctx=Store()))], body=[Assign(targets=[Name(id='data', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='f', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='project_name', ctx=Store()), Name(id='folders', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='data', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO projects(name) VALUES(?)'), Tuple(elts=[Name(id='project_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='project_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='folder_name', ctx=Store()), Name(id='files', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='folders', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO folders(name, project_id) VALUES(?, ?)'), Tuple(elts=[Name(id='folder_name', ctx=Load()), Name(id='project_id', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='folder_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='file_name', ctx=Store()), Name(id='file_contents', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='files', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='file_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='docstring')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='INSERT INTO files(name, docstring, folder_id) VALUES(?, ?, ?)'), Tuple(elts=[Name(id='file_name', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='folder_id', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='file_id', ctx=Store())], value=Attribute(value=Name(id='cursor', ctx=Load()), attr='lastrowid', ctx=Load())), For(target=Tuple(elts=[Name(id='function_name', ctx=Store()), Name(id='function_contents', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='file_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='functions_and_classes'), Dict(keys=[], values=[])], keywords=[]), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='nl_description', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='nl_description')], keywords=[])), Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='docstring')], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='ast_output')], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='function_contents', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='source_code')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n                        INSERT INTO functions_classes(name, nl_description, docstring, ast_output, source_code, file_id) \\n                        VALUES(?, ?, ?, ?, ?, ?)\\n                    '), Tuple(elts=[Name(id='function_name', ctx=Load()), Name(id='nl_description', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load()), Name(id='file_id', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='commit', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef parse_json_insert_data(conn, json_file_path):\n    with open(json_file_path, 'r') as f:\n        data = json.load(f)\n    cursor = conn.cursor()\n    for (project_name, folders) in data.items():\n        cursor.execute('INSERT INTO projects(name) VALUES(?)', (project_name,))\n        project_id = cursor.lastrowid\n        for (folder_name, files) in folders.items():\n            cursor.execute('INSERT INTO folders(name, project_id) VALUES(?, ?)', (folder_name, project_id))\n            folder_id = cursor.lastrowid\n            for (file_name, file_contents) in files.items():\n                docstring = file_contents.get('docstring')\n                cursor.execute('INSERT INTO files(name, docstring, folder_id) VALUES(?, ?, ?)', (file_name, docstring, folder_id))\n                file_id = cursor.lastrowid\n                for (function_name, function_contents) in file_contents.get('functions_and_classes', {}).items():\n                    nl_description = function_contents.get('nl_description')\n                    docstring = function_contents.get('docstring')\n                    ast_output = function_contents.get('ast_output')\n                    source_code = function_contents.get('source_code')\n                    cursor.execute('\\n                        INSERT INTO functions_classes(name, nl_description, docstring, ast_output, source_code, file_id) \\n                        VALUES(?, ?, ?, ?, ?, ?)\\n                    ', (function_name, nl_description, docstring, ast_output, source_code, file_id))\n    conn.commit()\n"
          },
          "query_function_class": {
            "nl_description": "This code defines a function called `query_function_class` that takes in several parameters: `conn`, `project_name`, `folder_name`, `file_name`, and `function_class_name`. \n\nInside the function, a cursor object is created using the `conn` parameter. The cursor is then used to execute a SQL query. The query selects several columns (`name`, `nl_description`, `docstring`, `ast_output`, `source_code`) from a table called `functions_classes`. The query also joins the `files`, `folders`, and `projects` tables based on their respective foreign key relationships. The `WHERE` clause filters the results based on the provided parameters (`function_class_name`, `file_name`, `folder_name`, `project_name`).\n\nThe `cursor.fetchall()` method is called to retrieve all the rows returned by the query. Then, a loop iterates over each row and prints it to the console using the `print()` function.",
            "docstring": null,
            "ast_output": "FunctionDef(name='query_function_class', args=arguments(posonlyargs=[], args=[arg(arg='conn'), arg(arg='project_name'), arg(arg='folder_name'), arg(arg='file_name'), arg(arg='function_class_name')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='cursor', ctx=Store())], value=Call(func=Attribute(value=Name(id='conn', ctx=Load()), attr='cursor', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='execute', ctx=Load()), args=[Constant(value='\\n        SELECT \\n            f_c.name, \\n            f_c.nl_description, \\n            f_c.docstring, \\n            f_c.ast_output, \\n            f_c.source_code \\n        FROM functions_classes f_c\\n        JOIN files f ON f_c.file_id = f.id\\n        JOIN folders fo ON f.folder_id = fo.id\\n        JOIN projects p ON fo.project_id = p.id\\n        WHERE \\n            f_c.name = ? AND\\n            f.name = ? AND\\n            fo.name = ? AND\\n            p.name = ?\\n    '), Tuple(elts=[Name(id='function_class_name', ctx=Load()), Name(id='file_name', ctx=Load()), Name(id='folder_name', ctx=Load()), Name(id='project_name', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='rows', ctx=Store())], value=Call(func=Attribute(value=Name(id='cursor', ctx=Load()), attr='fetchall', ctx=Load()), args=[], keywords=[])), For(target=Name(id='row', ctx=Store()), iter=Name(id='rows', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='row', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])",
            "source_code": "\n\ndef query_function_class(conn, project_name, folder_name, file_name, function_class_name):\n    cursor = conn.cursor()\n    cursor.execute('\\n        SELECT \\n            f_c.name, \\n            f_c.nl_description, \\n            f_c.docstring, \\n            f_c.ast_output, \\n            f_c.source_code \\n        FROM functions_classes f_c\\n        JOIN files f ON f_c.file_id = f.id\\n        JOIN folders fo ON f.folder_id = fo.id\\n        JOIN projects p ON fo.project_id = p.id\\n        WHERE \\n            f_c.name = ? AND\\n            f.name = ? AND\\n            fo.name = ? AND\\n            p.name = ?\\n    ', (function_class_name, file_name, folder_name, project_name))\n    rows = cursor.fetchall()\n    for row in rows:\n        print(row)\n"
          },
          "main": {
            "nl_description": "A Python function called main is defined. The function takes two parameters: json_file_path and db_file_path. \n\nInside the function, a connection to a database is created using the create_connection function, passing in the db_file_path parameter. \n\nThen, the create_tables function is called, passing in the connection object as a parameter. This function is responsible for creating tables in the database. \n\nFinally, the parse_json_insert_data function is called, passing in the connection object and json_file_path parameter. This function is responsible for parsing a JSON file and inserting the data into the database.",
            "docstring": null,
            "ast_output": "FunctionDef(name='main', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Name(id='create_connection', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='create_tables', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='parse_json_insert_data', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='json_file_path', ctx=Load())], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef main(json_file_path, db_file_path):\n    conn = create_connection(db_file_path)\n    create_tables(conn)\n    parse_json_insert_data(conn, json_file_path)\n"
          },
          "test_main": {
            "nl_description": "A Python function called test_main is defined. The function takes two parameters: json_file_path and db_file_path. \n\nInside the function, a connection to a database is created using the create_connection function, passing in the db_file_path parameter. \n\nThen, the create_tables function is called, passing in the conn variable as an argument. This function is responsible for creating tables in the database. \n\nNext, the parse_json_insert_data function is called, passing in the conn variable and json_file_path parameter. This function is responsible for parsing a JSON file and inserting the data into the database. \n\nFinally, the query_function_class function is called, passing in the conn variable, as well as the strings 'codebase_assistant', 'src', 'parser', and 'extract_info'. This function is responsible for querying the database using the provided parameters.",
            "docstring": null,
            "ast_output": "FunctionDef(name='test_main', args=arguments(posonlyargs=[], args=[arg(arg='json_file_path'), arg(arg='db_file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='conn', ctx=Store())], value=Call(func=Name(id='create_connection', ctx=Load()), args=[Name(id='db_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='create_tables', ctx=Load()), args=[Name(id='conn', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='parse_json_insert_data', ctx=Load()), args=[Name(id='conn', ctx=Load()), Name(id='json_file_path', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='query_function_class', ctx=Load()), args=[Name(id='conn', ctx=Load()), Constant(value='codebase_assistant'), Constant(value='src'), Constant(value='parser'), Constant(value='extract_info')], keywords=[]))], decorator_list=[])",
            "source_code": "\n\ndef test_main(json_file_path, db_file_path):\n    conn = create_connection(db_file_path)\n    create_tables(conn)\n    parse_json_insert_data(conn, json_file_path)\n    query_function_class(conn, 'codebase_assistant', 'src', 'parser', 'extract_info')\n"
          }
        }
      },
      "gpt_funcs": {
        "docstring": null,
        "functions_and_classes": {
          "code_to_nl": {
            "nl_description": "This is a Python function called `code_to_nl` that takes in three parameters: `input_content`, `model_temperature`, and `model`. \n\nInside the function, there is a variable called `system_message` that is a dictionary with two key-value pairs. The keys are `'role'` and `'content'`, and the values are `'system'` and a long string explaining the purpose of the AI, respectively.\n\nThere is also a variable called `user_message` that is a dictionary with two key-value pairs. The keys are `'role'` and `'content'`, and the value of `'content'` is the value of the `input_content` parameter passed into the function.\n\nThe next line of code makes a call to the OpenAI API using the `openai.ChatCompletion.create` method. It passes in the `model`, `messages`, and `temperature` parameters. The `model` parameter is set to the value of the `model` parameter passed into the function. The `messages` parameter is a list containing the `system_message` and `user_message` dictionaries. The `temperature` parameter is set to the value of the `model_temperature` parameter passed into the function.\n\nFinally, the function returns the content of the response received from the OpenAI API. The content is accessed using dictionary indexing to get the value of `'choices'`, then indexing again to get the first element of the resulting list, and finally indexing again to get the value of `'message'` and `'content'`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='code_to_nl', args=arguments(posonlyargs=[], args=[arg(arg='input_content'), arg(arg='model_temperature'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.1), Constant(value='gpt-3.5-turbo')]), body=[Assign(targets=[Name(id='system_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='system'), Constant(value=\"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\")])), Assign(targets=[Name(id='user_message', ctx=Store())], value=Dict(keys=[Constant(value='role'), Constant(value='content')], values=[Constant(value='user'), Name(id='input_content', ctx=Load())])), Assign(targets=[Name(id='response', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='openai', ctx=Load()), attr='ChatCompletion', ctx=Load()), attr='create', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='messages', value=List(elts=[Name(id='system_message', ctx=Load()), Name(id='user_message', ctx=Load())], ctx=Load())), keyword(arg='temperature', value=Name(id='model_temperature', ctx=Load()))])), Return(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='response', ctx=Load()), slice=Constant(value='choices'), ctx=Load()), slice=Constant(value=0), ctx=Load()), slice=Constant(value='message'), ctx=Load()), slice=Constant(value='content'), ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef code_to_nl(input_content, model_temperature=0.1, model='gpt-3.5-turbo'):\n    system_message = {'role': 'system', 'content': \"You are an AI trained by openai to read code and translate what the code does into natural language. For example the python code `def hello_world(): print('Hello World!')` your response would be `A Python function called hello_world is defined. When the function is called, it prints 'Hello World!' to the console.`. Code may contain newline characters, represented with a backslash followed by the letter n, you can ignore these as they are not a part of the actual code.\"}\n    user_message = {'role': 'user', 'content': input_content}\n    response = openai.ChatCompletion.create(model=model, messages=[system_message, user_message], temperature=model_temperature)\n    return response['choices'][0]['message']['content']\n"
          }
        }
      },
      "parser": {
        "docstring": null,
        "functions_and_classes": {
          "extract_info": {
            "nl_description": "This code defines a function called `extract_info` that takes a parameter called `node`. \n\nInside the function, it checks if the `node` is an instance of either `ast.FunctionDef` or `ast.ClassDef`. If it is, it proceeds to extract information from the `node`.\n\nIt first calls `ast.get_docstring(node)` to get the docstring of the `node` and assigns it to the variable `docstring`.\n\nThen, it calls `ast.dump(node)` to get a string representation of the `node` and assigns it to the variable `ast_output`.\n\nNext, it calls `astunparse.unparse(node)` to get the source code of the `node` and assigns it to the variable `source_code`.\n\nFinally, it calls a function called `code_to_nl` with the `source_code` as an argument to convert the source code into natural language description and assigns the result to the variable `nl_description`.\n\nThe function then returns a dictionary with the keys `'nl_description'`, `'docstring'`, `'ast_output'`, and `'source_code'`, and their corresponding values `nl_description`, `docstring`, `ast_output`, and `source_code` respectively.\n\nIf the `node` is not an instance of `ast.FunctionDef` or `ast.ClassDef`, the function returns `None`.",
            "docstring": null,
            "ast_output": "FunctionDef(name='extract_info', args=arguments(posonlyargs=[], args=[arg(arg='node')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='node', ctx=Load()), Tuple(elts=[Attribute(value=Name(id='ast', ctx=Load()), attr='FunctionDef', ctx=Load()), Attribute(value=Name(id='ast', ctx=Load()), attr='ClassDef', ctx=Load())], ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ast_output', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='dump', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='astunparse', ctx=Load()), attr='unparse', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), Assign(targets=[Name(id='nl_desription', ctx=Store())], value=Call(func=Name(id='code_to_nl', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Return(value=Dict(keys=[Constant(value='nl_description'), Constant(value='docstring'), Constant(value='ast_output'), Constant(value='source_code')], values=[Name(id='nl_desription', ctx=Load()), Name(id='docstring', ctx=Load()), Name(id='ast_output', ctx=Load()), Name(id='source_code', ctx=Load())]))], orelse=[Return(value=Constant(value=None))])], decorator_list=[])",
            "source_code": "\n\ndef extract_info(node):\n    if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n        docstring = ast.get_docstring(node)\n        ast_output = ast.dump(node)\n        source_code = astunparse.unparse(node)\n        nl_desription = code_to_nl(source_code)\n        return {'nl_description': nl_desription, 'docstring': docstring, 'ast_output': ast_output, 'source_code': source_code}\n    else:\n        return None\n"
          },
          "parse_file": {
            "nl_description": "This code defines a function called `parse_file` that takes a `file_path` as input. \n\nInside the function, it opens the file specified by `file_path` in read mode using the `open` function and assigns the file object to the variable `file`. \n\nIt then reads the contents of the file using the `read` method of the file object and assigns the result to the variable `source_code`. \n\nThe `ast.parse` function is used to parse the `source_code` and create an abstract syntax tree (AST) representation of the code. \n\nThe `ast.get_docstring` function is used to extract the docstring (if any) from the module represented by the AST and assigns it to the variable `module_docstring`. \n\nA dictionary called `functions_and_classes` is created to store information about functions and classes found in the module. \n\nThe code then iterates over the `body` attribute of the module's AST representation and calls a function called `extract_info` on each node. The result of `extract_info` is assigned to the variable `info`. \n\nIf `info` is not `None`, meaning that `extract_info` returned some information, the code adds an entry to the `functions_and_classes` dictionary with the node's name as the key and `info` as the value. \n\nFinally, the function returns a dictionary with two keys: `'docstring'` and `'functions_and_classes'`. The value associated with the `'docstring'` key is the `module_docstring` variable, and the value associated with the `'functions_and_classes'` key is the `functions_and_classes` dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_file', args=arguments(posonlyargs=[], args=[arg(arg='file_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Name(id='file_path', ctx=Load()), Constant(value='r')], keywords=[]), optional_vars=Name(id='file', ctx=Store()))], body=[Assign(targets=[Name(id='source_code', ctx=Store())], value=Call(func=Attribute(value=Name(id='file', ctx=Load()), attr='read', ctx=Load()), args=[], keywords=[]))]), Assign(targets=[Name(id='module', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='parse', ctx=Load()), args=[Name(id='source_code', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_docstring', ctx=Store())], value=Call(func=Attribute(value=Name(id='ast', ctx=Load()), attr='get_docstring', ctx=Load()), args=[Name(id='module', ctx=Load())], keywords=[])), Assign(targets=[Name(id='functions_and_classes', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='node', ctx=Store()), iter=Attribute(value=Name(id='module', ctx=Load()), attr='body', ctx=Load()), body=[Assign(targets=[Name(id='info', ctx=Store())], value=Call(func=Name(id='extract_info', ctx=Load()), args=[Name(id='node', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='info', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='functions_and_classes', ctx=Load()), slice=Attribute(value=Name(id='node', ctx=Load()), attr='name', ctx=Load()), ctx=Store())], value=Name(id='info', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Dict(keys=[Constant(value='docstring'), Constant(value='functions_and_classes')], values=[Name(id='module_docstring', ctx=Load()), Name(id='functions_and_classes', ctx=Load())]))], decorator_list=[])",
            "source_code": "\n\ndef parse_file(file_path):\n    with open(file_path, 'r') as file:\n        source_code = file.read()\n    module = ast.parse(source_code)\n    module_docstring = ast.get_docstring(module)\n    functions_and_classes = {}\n    for node in module.body:\n        info = extract_info(node)\n        if (info is not None):\n            functions_and_classes[node.name] = info\n    return {'docstring': module_docstring, 'functions_and_classes': functions_and_classes}\n"
          },
          "parse_directory": {
            "nl_description": "This code defines a function called `parse_directory` that takes a `directory_path` as input. \n\nInside the function, an empty dictionary called `modules` is created. \n\nThen, a loop iterates over the files in the specified directory using `os.listdir(directory_path)`. \n\nFor each file, it checks if the file ends with the extension '.py' using `filename.endswith('.py')`. \n\nIf the file has the '.py' extension, it creates the full file path by joining the directory path and the filename using `os.path.join(directory_path, filename)`. \n\nIt then extracts the module name by removing the file extension using `os.path.splitext(filename)[0]`. \n\nThe code then calls a function called `parse_file` with the file path as an argument and assigns the result to the `modules` dictionary with the module name as the key. \n\nFinally, the function returns the `modules` dictionary.",
            "docstring": null,
            "ast_output": "FunctionDef(name='parse_directory', args=arguments(posonlyargs=[], args=[arg(arg='directory_path')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='modules', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='filename', ctx=Store()), iter=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='listdir', ctx=Load()), args=[Name(id='directory_path', ctx=Load())], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='filename', ctx=Load()), attr='endswith', ctx=Load()), args=[Constant(value='.py')], keywords=[]), body=[Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='directory_path', ctx=Load()), Name(id='filename', ctx=Load())], keywords=[])), Assign(targets=[Name(id='module_name', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='splitext', ctx=Load()), args=[Name(id='filename', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Assign(targets=[Subscript(value=Name(id='modules', ctx=Load()), slice=Name(id='module_name', ctx=Load()), ctx=Store())], value=Call(func=Name(id='parse_file', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='modules', ctx=Load()))], decorator_list=[])",
            "source_code": "\n\ndef parse_directory(directory_path):\n    modules = {}\n    for filename in os.listdir(directory_path):\n        if filename.endswith('.py'):\n            file_path = os.path.join(directory_path, filename)\n            module_name = os.path.splitext(filename)[0]\n            modules[module_name] = parse_file(file_path)\n    return modules\n"
          }
        }
      },
      "__init__": {
        "docstring": null,
        "functions_and_classes": {}
      }
    }
  }
}